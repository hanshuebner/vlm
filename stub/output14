/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunsubp.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* Subprimitives. */
/* start DoEphemeralp */

  /* Halfword operand from stack instruction - DoEphemeralp */

doephemeralp:
  if (_trace) printf("doephemeralp:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoEphemeralpIM:
  if (_trace) printf("DoEphemeralpIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g8083:
  if (_trace) printf("g8083:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoephemeralp;
#ifdef TRACING
#endif

DoEphemeralpSP:
  if (_trace) printf("DoEphemeralpSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoephemeralp;
#endif

DoEphemeralpLP:
  if (_trace) printf("DoEphemeralpLP:\n");
#ifdef TRACING
  goto headdoephemeralp;
#endif

DoEphemeralpFP:
  if (_trace) printf("DoEphemeralpFP:\n");

headdoephemeralp:
  if (_trace) printf("headdoephemeralp:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoephemeralp:
  if (_trace) printf("begindoephemeralp:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* ptr type array */
  t1 = *(u64 *)&(processor->ptrtype);
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  /* TagType. */
  arg2 = arg2 & 63;
  t2 = (arg2 * 4) + t1;
  arg1 = arg1 >> 27;
  /* =0 if not a pointer */
  t3 = *(s32 *)t2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* J. if zone not ephemeral */
  if (arg1 != 0)
    goto nonephem;
  /* J. if not a pointer */
  if (t3 == 0)
    goto nonephem;
  t6 = *(u64 *)&(processor->taddress);
  /* push the data */
  *(u64 *)(iSP + 8) = t6;
  iSP = iSP + 8;
  goto cachevalid;

nonephem:
  if (_trace) printf("nonephem:\n");
  t6 = *(u64 *)&(processor->niladdress);
  /* push the data */
  *(u64 *)(iSP + 8) = t6;
  iSP = iSP + 8;
  goto cachevalid;

/* end DoEphemeralp */
  /* End of Halfword operand from stack instruction - DoEphemeralp */
/* start DoUnsignedLessp */

  /* Halfword operand from stack instruction - DoUnsignedLessp */
  /* arg2 has the preloaded 8 bit operand. */

dounsignedlessp:
  if (_trace) printf("dounsignedlessp:\n");
#ifdef TRACING
#endif

DoUnsignedLesspSP:
  if (_trace) printf("DoUnsignedLesspSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdounsignedlessp;
#endif

DoUnsignedLesspLP:
  if (_trace) printf("DoUnsignedLesspLP:\n");
#ifdef TRACING
  goto headdounsignedlessp;
#endif

DoUnsignedLesspFP:
  if (_trace) printf("DoUnsignedLesspFP:\n");

headdounsignedlessp:
  if (_trace) printf("headdounsignedlessp:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindounsignedlessp:
  if (_trace) printf("begindounsignedlessp:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get data from arg1 */
  t2 = *(s32 *)iSP;
  arg3 = arg3 >> 12;
  t11 = *(u64 *)&(processor->niladdress);
  /* Get unsigned data from arg2 */
  t4 = (u32)arg1;
  t12 = *(u64 *)&(processor->taddress);
  /* 1 if no-pop, 0 if pop */
  arg3 = arg3 & 1;
  /* Unsigned arg1 */
  t2 = (u32)t2;
  /* Either a stack-push or a stack-write */
  iSP = (arg3 * 8) + iSP;
  /* t6:=arg2-arg1 unsigned */
  t6 = t4 - t2;
  if ((s64)t6 > 0)
    t11 = t12;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u64 *)iSP = t11;
  goto cachevalid;
#ifdef TRACING
  goto DoUnsignedLesspIM;
#endif

DoUnsignedLesspIM:
  if (_trace) printf("DoUnsignedLesspIM:\n");
  /* Get data from arg1 */
  t2 = *(s32 *)iSP;
  arg3 = arg3 >> 12;
  t11 = *(u64 *)&(processor->niladdress);
  /* ... */
  t2 = (u32)t2;
  t12 = *(u64 *)&(processor->taddress);
  /* 1 if no-pop, 0 if pop */
  arg3 = arg3 & 1;
  /* t6:=arg2-arg1 unsigned */
  t6 = arg2 - t2;
  /* Either a stack-push or a stack-write */
  iSP = (arg3 * 8) + iSP;
  if ((s64)t6 > 0)
    t11 = t12;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u64 *)iSP = t11;
  goto cachevalid;

/* end DoUnsignedLessp */
  /* End of Halfword operand from stack instruction - DoUnsignedLessp */
/* start DoAllocateListBlock */

  /* Halfword operand from stack instruction - DoAllocateListBlock */
  /* arg2 has the preloaded 8 bit operand. */

doallocatelistblock:
  if (_trace) printf("doallocatelistblock:\n");
#ifdef TRACING
#endif

DoAllocateListBlockIM:
  if (_trace) printf("DoAllocateListBlockIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoallocatelistblock;
#ifdef TRACING
#endif

DoAllocateListBlockSP:
  if (_trace) printf("DoAllocateListBlockSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoallocatelistblock;
#endif

DoAllocateListBlockLP:
  if (_trace) printf("DoAllocateListBlockLP:\n");
#ifdef TRACING
  goto headdoallocatelistblock;
#endif

DoAllocateListBlockFP:
  if (_trace) printf("DoAllocateListBlockFP:\n");

headdoallocatelistblock:
  if (_trace) printf("headdoallocatelistblock:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoallocatelistblock:
  if (_trace) printf("begindoallocatelistblock:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t1 = *(u64 *)&(processor->lcarea);
  arg3 = *(u64 *)iSP;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t5 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g8084;
  t4 = *(s32 *)&processor->lclength;
  t2 = (arg3 == t1) ? 1 : 0;
  /* Wrong area */
  if (t2 == 0)
    goto g8085;
  /* Effectively an unsigned 32-bit compare */
  t2 = t4 - arg1;
  /* Insufficient cache */
  if ((s64)t2 < 0)
    goto g8085;
  /* Fetch address */
  t1 = *(u64 *)&(processor->lcaddress);
  t3 = (-16384) << 16;
  t3 = (u32)t3;
  /* Store remaining length */
  *(u32 *)&processor->lclength = t2;
  /* Cache address/tag -> TOS */
  *(u64 *)iSP = t1;
  /* Cache address -> BAR1 */
  *(u32 *)&processor->bar1 = t1;
  t1 = (u32)t1;
  /* Verify trap mode */
  t4 = *(s32 *)&processor->control;
  /* Increment address */
  t1 = t1 + arg1;
  /* Store updated address */
  *(u32 *)&processor->lcaddress = t1;
  t3 = t3 & t4;
  /* Already above emulator mode */
  if (t3 != 0)
    goto NEXTINSTRUCTION;
  t3 = (16384) << 16;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  goto NEXTINSTRUCTION;

g8084:
  if (_trace) printf("g8084:\n");
  arg5 = 0;
  arg2 = 1;
  goto illegaloperand;

g8085:
  if (_trace) printf("g8085:\n");
  /* SetTag. */
  t1 = arg2 << 32;
  t1 = arg1 | t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

/* end DoAllocateListBlock */
  /* End of Halfword operand from stack instruction - DoAllocateListBlock */
/* start DoAllocateStructureBlock */

  /* Halfword operand from stack instruction - DoAllocateStructureBlock */
  /* arg2 has the preloaded 8 bit operand. */

doallocatestructureblock:
  if (_trace) printf("doallocatestructureblock:\n");
#ifdef TRACING
#endif

DoAllocateStructureBlockIM:
  if (_trace) printf("DoAllocateStructureBlockIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoallocatestructureblock;
#ifdef TRACING
#endif

DoAllocateStructureBlockSP:
  if (_trace) printf("DoAllocateStructureBlockSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoallocatestructureblock;
#endif

DoAllocateStructureBlockLP:
  if (_trace) printf("DoAllocateStructureBlockLP:\n");
#ifdef TRACING
  goto headdoallocatestructureblock;
#endif

DoAllocateStructureBlockFP:
  if (_trace) printf("DoAllocateStructureBlockFP:\n");

headdoallocatestructureblock:
  if (_trace) printf("headdoallocatestructureblock:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoallocatestructureblock:
  if (_trace) printf("begindoallocatestructureblock:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t1 = *(u64 *)&(processor->scarea);
  arg3 = *(u64 *)iSP;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t5 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g8086;
  t4 = *(s32 *)&processor->sclength;
  t2 = (arg3 == t1) ? 1 : 0;
  /* Wrong area */
  if (t2 == 0)
    goto g8087;
  /* Effectively an unsigned 32-bit compare */
  t2 = t4 - arg1;
  /* Insufficient cache */
  if ((s64)t2 < 0)
    goto g8087;
  /* Fetch address */
  t1 = *(u64 *)&(processor->scaddress);
  t3 = (-16384) << 16;
  t3 = (u32)t3;
  /* Store remaining length */
  *(u32 *)&processor->sclength = t2;
  /* Cache address/tag -> TOS */
  *(u64 *)iSP = t1;
  /* Cache address -> BAR1 */
  *(u32 *)&processor->bar1 = t1;
  t1 = (u32)t1;
  /* Verify trap mode */
  t4 = *(s32 *)&processor->control;
  /* Increment address */
  t1 = t1 + arg1;
  /* Store updated address */
  *(u32 *)&processor->scaddress = t1;
  t3 = t3 & t4;
  /* Already above emulator mode */
  if (t3 != 0)
    goto NEXTINSTRUCTION;
  t3 = (16384) << 16;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  goto NEXTINSTRUCTION;

g8086:
  if (_trace) printf("g8086:\n");
  arg5 = 0;
  arg2 = 1;
  goto illegaloperand;

g8087:
  if (_trace) printf("g8087:\n");
  /* SetTag. */
  t1 = arg2 << 32;
  t1 = arg1 | t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

/* end DoAllocateStructureBlock */
  /* End of Halfword operand from stack instruction - DoAllocateStructureBlock */
/* start DoPointerDifference */

  /* Halfword operand from stack instruction - DoPointerDifference */
  /* arg2 has the preloaded 8 bit operand. */

dopointerdifference:
  if (_trace) printf("dopointerdifference:\n");
#ifdef TRACING
#endif

DoPointerDifferenceSP:
  if (_trace) printf("DoPointerDifferenceSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdopointerdifference;
#endif

DoPointerDifferenceLP:
  if (_trace) printf("DoPointerDifferenceLP:\n");
#ifdef TRACING
  goto headdopointerdifference;
#endif

DoPointerDifferenceFP:
  if (_trace) printf("DoPointerDifferenceFP:\n");

headdopointerdifference:
  if (_trace) printf("headdopointerdifference:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindopointerdifference:
  if (_trace) printf("begindopointerdifference:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get the data of ARG1 */
  t1 = *(s32 *)iSP;
  /* Get the data of ARG2 */
  t2 = (u32)arg1;
  /* (%32-bit-difference (data arg1) (data arg2)) */
  t3 = (s32)t1 - (s32)t2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t4 = Type_Fixnum;
  /* Save result and coerce to a FIXNUM */
  *(u32 *)iSP = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;
#ifdef TRACING
  goto DoPointerDifferenceIM;
#endif

DoPointerDifferenceIM:
  if (_trace) printf("DoPointerDifferenceIM:\n");
  t2 = arg2 << 56;
  /* Get the data of arg1 */
  t1 = *(s32 *)iSP;
  t2 = (s64)t2 >> 56;
  /* (%32-bit-difference (data arg1) (data arg2)) */
  t3 = (s32)t1 - (s32)t2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t4 = Type_Fixnum;
  /* Save result and coerce to a FIXNUM */
  *(u32 *)iSP = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;

/* end DoPointerDifference */
  /* End of Halfword operand from stack instruction - DoPointerDifference */
/* start DoPointerIncrement */

  /* Halfword operand from stack instruction - DoPointerIncrement */
  /* arg2 has the preloaded 8 bit operand. */

dopointerincrement:
  if (_trace) printf("dopointerincrement:\n");
#ifdef TRACING
#endif

DoPointerIncrementSP:
  if (_trace) printf("DoPointerIncrementSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindopointerincrement;
#endif

DoPointerIncrementLP:
  if (_trace) printf("DoPointerIncrementLP:\n");
#ifdef TRACING
  goto begindopointerincrement;
#endif

DoPointerIncrementFP:
  if (_trace) printf("DoPointerIncrementFP:\n");

begindopointerincrement:
  if (_trace) printf("begindopointerincrement:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the data of arg2 */
  t2 = *(s32 *)arg1;
  /* (%32-bit-plus (data arg1) 1) */
  t3 = (s32)t2 + (s32)1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Put result back */
  *(u32 *)arg1 = t3;
  goto cachevalid;
#ifdef TRACING
#endif

DoPointerIncrementIM:
  goto doistageerror;

/* end DoPointerIncrement */
  /* End of Halfword operand from stack instruction - DoPointerIncrement */
/* start DoStoreConditional */

  /* Halfword operand from stack instruction - DoStoreConditional */

dostoreconditional:
  if (_trace) printf("dostoreconditional:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoStoreConditionalIM:
  if (_trace) printf("DoStoreConditionalIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g8104:
  if (_trace) printf("g8104:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindostoreconditional;
#ifdef TRACING
#endif

DoStoreConditionalSP:
  if (_trace) printf("DoStoreConditionalSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdostoreconditional;
#endif

DoStoreConditionalLP:
  if (_trace) printf("DoStoreConditionalLP:\n");
#ifdef TRACING
  goto headdostoreconditional;
#endif

DoStoreConditionalFP:
  if (_trace) printf("DoStoreConditionalFP:\n");

headdostoreconditional:
  if (_trace) printf("headdostoreconditional:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindostoreconditional:
  if (_trace) printf("begindostoreconditional:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;
  /* old tag and data */
  arg4 = *(s32 *)iSP;
  /* old tag and data */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  arg1 = (u32)arg1;
  /* address tag and data */
  arg6 = *(s32 *)iSP;
  /* address tag and data */
  arg5 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg6 = (u32)arg6;
  /* TagType. */
  t1 = arg5 & 63;
  t2 = t1 - Type_Locative;
  /* Strip CDR code */
  t2 = t2 & 63;
  if (t2 != 0)
    goto storecondiop;
  /* Read the location, checking write access */
  /* Memory Read Internal */

g8088:
  /* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg6 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  t5 = (t3 * 4);
  t4 = LDQ_U(t3);
  /* Stack cache offset */
  t1 = arg6 - t1;
  /* In range? */
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t3&7)*8));
  if (t2 != 0)
    goto g8090;

g8089:
  t1 = *(u64 *)&(processor->dataread_mask);
  t3 = zero + 240;
  t1 = t1 >> (t4 & 63);
  t3 = t3 >> (t4 & 63);
  if (t1 & 1)
    goto g8092;

g8099:
  /* Check for data match - NOT */
  t1 = (s32)arg4 - (s32)t5;
  /* Zero if tags match */
  t2 = arg3 ^ t4;
  /* Jump if data didn't match */
  if (t1 != 0)
    goto storecondnil;
  /* TagType. */
  /* Stip result of comparing CDR-CODEs */
  t2 = t2 & 63;
  /* Jump if tags don't match */
  if (t2 != 0)
    goto storecondnil;
  /* Strip CDR-CODE */
  t1 = arg2 & 63;
  /* Retain CDR-CODE */
  t4 = t4 & 192;
  /* Merge new tag with old CDR-CODE */
  t4 = t1 | t4;
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t1 = arg6 + ivory;
  t6 = *(s32 *)&processor->scovlimit;
  t5 = (t1 * 4);
  t3 = LDQ_U(t1);
  /* Stack cache offset */
  t2 = arg6 - t2;
  /* In range? */
  t6 = ((u64)t2 < (u64)t6) ? 1 : 0;
  t2 = (t4 & 0xff) << ((t1&7)*8);
  t3 = t3 & ~(0xffL << (t1&7)*8);

g8102:
  if (_trace) printf("g8102:\n");
  t3 = t3 | t2;
  STQ_U(t1, t3);
  *(u32 *)t5 = arg1;
  /* J. if in cache */
  if (t6 != 0)
    goto g8101;

g8100:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t6 = *(u64 *)&(processor->taddress);
  /* push the data */
  *(u64 *)(iSP + 8) = t6;
  iSP = iSP + 8;
  goto cachevalid;

storecondnil:
  if (_trace) printf("storecondnil:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t6 = *(u64 *)&(processor->niladdress);
  /* push the data */
  *(u64 *)(iSP + 8) = t6;
  iSP = iSP + 8;
  goto cachevalid;

storecondiop:
  if (_trace) printf("storecondiop:\n");
  arg5 = 0;
  arg2 = 65;
  goto illegaloperand;

g8101:
  if (_trace) printf("g8101:\n");
  t2 = *(u64 *)&(processor->stackcachebasevma);

g8103:
  if (_trace) printf("g8103:\n");
  t1 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t2 = arg6 - t2;
  /* reconstruct SCA */
  t1 = (t2 * 8) + t1;
  /* Store in stack */
  *(u32 *)t1 = arg1;
  /* write the stack cache */
  *(u32 *)(t1 + 4) = t4;
  goto g8100;

g8090:
  if (_trace) printf("g8090:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  t5 = *(s32 *)t1;
  /* Read from stack cache */
  t4 = *(s32 *)(t1 + 4);
  goto g8089;

g8092:
  if (_trace) printf("g8092:\n");
  if ((t3 & 1) == 0)
    goto g8091;
  /* Do the indirect thing */
  arg6 = (u32)t5;
  goto g8088;

g8091:
  if (_trace) printf("g8091:\n");
  /* Load the memory action table for cycle */
  t1 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t3 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg6;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t1;
  /* Get the memory action */
  t1 = *(s32 *)t3;

g8096:
  if (_trace) printf("g8096:\n");
  t3 = t1 & MemoryActionTransform;
  if (t3 == 0)
    goto g8095;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g8099;
#ifndef MINIMA

g8095:
#endif
#ifdef MINIMA

g8095:
  if (_trace) printf("g8095:\n");
  t3 = t1 & MemoryActionBinding;
  t2 = *(u64 *)&(processor->dbcmask);
  if (t3 == 0)
    goto g8094;
  t1 = arg6 << 1;
  t3 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t1 = t1 & t2;
  t2 = 1;
  t2 = t2 << (ivorymemorydata & 63);
  t1 = (s32)t1 + (s32)t3;
  /* Clear sign-extension */
  t1 = (u32)t1;
  t2 = (t1 * 4) + t2;
  /* Fetch the key */
  t1 = *(s32 *)t2;
  /* Fetch value */
  t5 = *(s32 *)(t2 + 4);
  /* Compare */
  t3 = (s32)arg6 - (s32)t1;
  /* Trap on miss */
  if (t3 != 0)
    goto g8098;
  /* Extract the pointer, and indirect */
  arg6 = (u32)t5;
  goto g8088;

g8098:
  if (_trace) printf("g8098:\n");
  goto dbcachemisstrap;
#endif

g8094:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 0;
  goto performmemoryaction;

/* end DoStoreConditional */
  /* End of Halfword operand from stack instruction - DoStoreConditional */
/* start DoMemoryWrite */

  /* Halfword operand from stack instruction - DoMemoryWrite */

domemorywrite:
  if (_trace) printf("domemorywrite:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMemoryWriteIM:
  if (_trace) printf("DoMemoryWriteIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g8108:
  if (_trace) printf("g8108:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindomemorywrite;
#ifdef TRACING
#endif

DoMemoryWriteSP:
  if (_trace) printf("DoMemoryWriteSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdomemorywrite;
#endif

DoMemoryWriteLP:
  if (_trace) printf("DoMemoryWriteLP:\n");
#ifdef TRACING
  goto headdomemorywrite;
#endif

DoMemoryWriteFP:
  if (_trace) printf("DoMemoryWriteFP:\n");

headdomemorywrite:
  if (_trace) printf("headdomemorywrite:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindomemorywrite:
  if (_trace) printf("begindomemorywrite:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t1 = arg4 + ivory;
  t5 = *(s32 *)&processor->scovlimit;
  t4 = (t1 * 4);
  t3 = LDQ_U(t1);
  /* Stack cache offset */
  t2 = arg4 - t2;
  /* In range? */
  t5 = ((u64)t2 < (u64)t5) ? 1 : 0;
  t2 = (arg2 & 0xff) << ((t1&7)*8);
  t3 = t3 & ~(0xffL << (t1&7)*8);

g8106:
  if (_trace) printf("g8106:\n");
  t3 = t3 | t2;
  STQ_U(t1, t3);
  *(u32 *)t4 = arg1;
  /* J. if in cache */
  if (t5 != 0)
    goto g8105;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g8105:
  if (_trace) printf("g8105:\n");
  t2 = *(u64 *)&(processor->stackcachebasevma);

g8107:
  if (_trace) printf("g8107:\n");
  t1 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t2 = arg4 - t2;
  /* reconstruct SCA */
  t1 = (t2 * 8) + t1;
  /* Store in stack */
  *(u32 *)t1 = arg1;
  /* write the stack cache */
  *(u32 *)(t1 + 4) = arg2;
  goto NEXTINSTRUCTION;

/* end DoMemoryWrite */
  /* End of Halfword operand from stack instruction - DoMemoryWrite */
/* start DoPStoreContents */

  /* Halfword operand from stack instruction - DoPStoreContents */

dopstorecontents:
  if (_trace) printf("dopstorecontents:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoPStoreContentsIM:
  if (_trace) printf("DoPStoreContentsIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g8121:
  if (_trace) printf("g8121:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindopstorecontents;
#ifdef TRACING
#endif

DoPStoreContentsSP:
  if (_trace) printf("DoPStoreContentsSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdopstorecontents;
#endif

DoPStoreContentsLP:
  if (_trace) printf("DoPStoreContentsLP:\n");
#ifdef TRACING
  goto headdopstorecontents;
#endif

DoPStoreContentsFP:
  if (_trace) printf("DoPStoreContentsFP:\n");

headdopstorecontents:
  if (_trace) printf("headdopstorecontents:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindopstorecontents:
  if (_trace) printf("begindopstorecontents:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* address tag and data */
  arg4 = *(s32 *)iSP;
  /* address tag and data */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  /* Memory Read Internal */

g8109:
  /* Base of stack cache */
  t6 = *(u64 *)&(processor->stackcachebasevma);
  t8 = arg4 + ivory;
  t7 = *(s32 *)&processor->scovlimit;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg4 - t6;
  /* In range? */
  t7 = ((u64)t6 < (u64)t7) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g8111;

g8110:

g8117:
  /* Merge cdr-code */
  t5 = arg2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t6 = arg4 + ivory;
  t9 = *(s32 *)&processor->scovlimit;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg4 - t7;
  /* In range? */
  t9 = ((u64)t7 < (u64)t9) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g8119:
  if (_trace) printf("g8119:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = arg1;
  /* J. if in cache */
  if (t9 != 0)
    goto g8118;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g8118:
  if (_trace) printf("g8118:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);

g8120:
  if (_trace) printf("g8120:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg4 - t7;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = arg1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g8111:
  if (_trace) printf("g8111:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g8110;

/* end DoPStoreContents */
  /* End of Halfword operand from stack instruction - DoPStoreContents */
/* start DoSetCdrCode1 */

  /* Halfword operand from stack instruction - DoSetCdrCode1 */
  /* arg2 has the preloaded 8 bit operand. */

dosetcdrcode1:
  if (_trace) printf("dosetcdrcode1:\n");
#ifdef TRACING
#endif

DoSetCdrCode1SP:
  if (_trace) printf("DoSetCdrCode1SP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindosetcdrcode1;
#endif

DoSetCdrCode1LP:
  if (_trace) printf("DoSetCdrCode1LP:\n");
#ifdef TRACING
  goto begindosetcdrcode1;
#endif

DoSetCdrCode1FP:
  if (_trace) printf("DoSetCdrCode1FP:\n");

begindosetcdrcode1:
  if (_trace) printf("begindosetcdrcode1:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get CDR CODE/TAG of operand */
  t1 = *(s32 *)(arg1 + 4);
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Strip off any existing CDR code bits */
  t1 = t1 & 63;
  /* OR in the CDR */
  t1 = t1 | 64;
  /* Replace the CDE CODE/TAG */
  *(u32 *)(arg1 + 4) = t1;
  goto cachevalid;
#ifdef TRACING
#endif

DoSetCdrCode1IM:
  goto doistageerror;

/* end DoSetCdrCode1 */
  /* End of Halfword operand from stack instruction - DoSetCdrCode1 */
/* start DoSetCdrCode2 */

  /* Halfword operand from stack instruction - DoSetCdrCode2 */
  /* arg2 has the preloaded 8 bit operand. */

dosetcdrcode2:
  if (_trace) printf("dosetcdrcode2:\n");
#ifdef TRACING
#endif

DoSetCdrCode2SP:
  if (_trace) printf("DoSetCdrCode2SP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindosetcdrcode2;
#endif

DoSetCdrCode2LP:
  if (_trace) printf("DoSetCdrCode2LP:\n");
#ifdef TRACING
  goto begindosetcdrcode2;
#endif

DoSetCdrCode2FP:
  if (_trace) printf("DoSetCdrCode2FP:\n");

begindosetcdrcode2:
  if (_trace) printf("begindosetcdrcode2:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get CDR CODE/TAG of operand */
  t1 = *(s32 *)(arg1 + 4);
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Strip off any existing CDR code bits */
  t1 = t1 & 63;
  /* OR in the CDR */
  t1 = t1 | 128;
  /* Replace the CDE CODE/TAG */
  *(u32 *)(arg1 + 4) = t1;
  goto cachevalid;
#ifdef TRACING
#endif

DoSetCdrCode2IM:
  goto doistageerror;

/* end DoSetCdrCode2 */
  /* End of Halfword operand from stack instruction - DoSetCdrCode2 */
/* start DoJump */

  /* Halfword operand from stack instruction - DoJump */
  /* arg2 has the preloaded 8 bit operand. */

dojump:
  if (_trace) printf("dojump:\n");
#ifdef TRACING
#endif

DoJumpSP:
  if (_trace) printf("DoJumpSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindojump;
#endif

DoJumpLP:
  if (_trace) printf("DoJumpLP:\n");
#ifdef TRACING
  goto begindojump;
#endif

DoJumpFP:
  if (_trace) printf("DoJumpFP:\n");

begindojump:
  if (_trace) printf("begindojump:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Read address and even/odd PC tag. */
  t4 = *(s32 *)arg1;
  t3 = *(s32 *)(arg1 + 4);
  t4 = (u32)t4;
  t5 = t3 - Type_EvenPC;
  /* Strip CDR code, low bits */
  t5 = t5 & 62;
  if (t5 != 0)
    goto jexc;
  t4 = t4 << 1;
  iPC = t3 & 1;
  iPC = iPC + t4;
  t5 = t3 & 128;
  if (t5 == 0)
    goto interpretinstructionforjump;
  /* Bit 39=1 indicates we need to update control reg */
  /* Get the cleanup bit */
  t6 = t3 & 64;
  /* Processor control register. */
  t5 = *(u64 *)&(processor->control);
  /* shift into cleanup-in-progress place */
  t6 = t6 << 17;
  t7 = (128) << 16;
  /* Mask */
  t5 = t5 & ~t7;
  /* Set */
  t5 = t5 | t6;
  *(u64 *)&processor->control = t5;
  goto interpretinstructionforjump;

jexc:
  if (_trace) printf("jexc:\n");
  /* arg3 = stackp */
  arg3 = 1;
  /* arg1 = instruction arity */
  arg1 = 0;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;
#ifdef TRACING
#endif

DoJumpIM:
  goto doistageerror;

/* end DoJump */
  /* End of Halfword operand from stack instruction - DoJump */
/* start DoCheckPreemptRequest */

  /* Halfword 10 bit immediate instruction - DoCheckPreemptRequest */

docheckpreemptrequest:
  if (_trace) printf("docheckpreemptrequest:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoCheckPreemptRequestIM:
  if (_trace) printf("DoCheckPreemptRequestIM:\n");

DoCheckPreemptRequestSP:
  if (_trace) printf("DoCheckPreemptRequestSP:\n");

DoCheckPreemptRequestLP:
  if (_trace) printf("DoCheckPreemptRequestLP:\n");

DoCheckPreemptRequestFP:
  if (_trace) printf("DoCheckPreemptRequestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  t1 = *(s32 *)&processor->interruptreg;
  t2 = t1 & 2;
  t2 = (t2 == 2) ? 1 : 0;
  t1 = t1 | t2;
  *(u32 *)&processor->interruptreg = t1;
  if (t1 == 0)
    goto NEXTINSTRUCTION;
  *(u64 *)&processor->stop_interpreter = t1;
  goto NEXTINSTRUCTION;

/* end DoCheckPreemptRequest */
  /* End of Halfword operand from stack instruction - DoCheckPreemptRequest */
/* start DoHalt */

  /* Halfword 10 bit immediate instruction - DoHalt */

dohalt:
  if (_trace) printf("dohalt:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoHaltIM:
  if (_trace) printf("DoHaltIM:\n");

DoHaltSP:
  if (_trace) printf("DoHaltSP:\n");

DoHaltLP:
  if (_trace) printf("DoHaltLP:\n");

DoHaltFP:
  if (_trace) printf("DoHaltFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  t1 = *(s32 *)&processor->control;
  /* Isolate current trap mode (FEP mode = -1) */
  t1 = t1 >> 30;
  /* t1 is zero iff we're in trap mode FEP */
  t1 = (s32)t1 + (s32)1;
  if (t1 != 0)
    goto haltexc;
  goto haltmachine;

haltexc:
  if (_trace) printf("haltexc:\n");
  /* arg3 = stackp */
  arg3 = 1;
  /* arg1 = instruction arity */
  arg1 = 0;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

/* end DoHalt */
  /* End of Halfword operand from stack instruction - DoHalt */
/* start DoNoOp */

  /* Halfword 10 bit immediate instruction - DoNoOp */

donoop:
  if (_trace) printf("donoop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoNoOpIM:
  if (_trace) printf("DoNoOpIM:\n");

DoNoOpSP:
  if (_trace) printf("DoNoOpSP:\n");

DoNoOpLP:
  if (_trace) printf("DoNoOpLP:\n");

DoNoOpFP:
  if (_trace) printf("DoNoOpFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  goto NEXTINSTRUCTION;

/* end DoNoOp */
  /* End of Halfword operand from stack instruction - DoNoOp */
/* start DoAlu */

  /* Halfword operand from stack instruction - DoAlu */

doalu:
  if (_trace) printf("doalu:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoAluIM:
  if (_trace) printf("DoAluIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g8192:
  if (_trace) printf("g8192:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoalu;
#ifdef TRACING
#endif

DoAluSP:
  if (_trace) printf("DoAluSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoalu;
#endif

DoAluLP:
  if (_trace) printf("DoAluLP:\n");
#ifdef TRACING
  goto headdoalu;
#endif

DoAluFP:
  if (_trace) printf("DoAluFP:\n");

headdoalu:
  if (_trace) printf("headdoalu:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoalu:
  if (_trace) printf("begindoalu:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* Get tag of ARG2 */
  arg2 = arg1 >> 32;
  /* Get data of ARG2 */
  arg1 = (u32)arg1;
  /* Get ARG1 */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto aluexc;
  t1 = arg3 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto aluexc;
  arg5 = *(u64 *)&(processor->aluop);
  *(u64 *)&processor->aluoverflow = zero;
  arg6 = *(u64 *)&(processor->aluandrotatecontrol);
  t1 = (arg5 == ALUFunction_Boolean) ? 1 : 0;

g8182:
  if (_trace) printf("g8182:\n");
  if (t1 == 0)
    goto g8123;
  /* Here if argument ALUFunctionBoolean */
  t10 = arg6 >> 10;
  /* Extract the ALU boolean function */
  t10 = t10 & 15;
  t1 = (t10 == Boole_Clear) ? 1 : 0;

g8142:
  if (_trace) printf("g8142:\n");
  if (t1 != 0)
    goto g8124;

g8125:
  if (_trace) printf("g8125:\n");
  t1 = (t10 == Boole_And) ? 1 : 0;

g8143:
  if (_trace) printf("g8143:\n");
  if (t1 == 0)
    goto g8126;
  /* Here if argument BooleAnd */
  t10 = arg4 & arg1;
  goto g8124;

g8126:
  if (_trace) printf("g8126:\n");
  t1 = (t10 == Boole_AndC1) ? 1 : 0;

g8144:
  if (_trace) printf("g8144:\n");
  if (t1 == 0)
    goto g8127;
  /* Here if argument BooleAndC1 */
  t10 = arg1 & ~arg4;
  goto g8124;

g8127:
  if (_trace) printf("g8127:\n");
  t1 = (t10 == Boole_2) ? 1 : 0;

g8145:
  if (_trace) printf("g8145:\n");
  if (t1 == 0)
    goto g8128;
  /* Here if argument Boole2 */
  t10 = arg1;
  goto g8124;

g8128:
  if (_trace) printf("g8128:\n");
  t1 = (t10 == Boole_AndC2) ? 1 : 0;

g8146:
  if (_trace) printf("g8146:\n");
  if (t1 == 0)
    goto g8129;
  /* Here if argument BooleAndC2 */
  t10 = arg4 & ~arg1;
  goto g8124;

g8129:
  if (_trace) printf("g8129:\n");
  t1 = (t10 == Boole_1) ? 1 : 0;

g8147:
  if (_trace) printf("g8147:\n");
  if (t1 == 0)
    goto g8130;
  /* Here if argument Boole1 */
  t10 = arg4;
  goto g8124;

g8130:
  if (_trace) printf("g8130:\n");
  t1 = (t10 == Boole_Xor) ? 1 : 0;

g8148:
  if (_trace) printf("g8148:\n");
  if (t1 == 0)
    goto g8131;
  /* Here if argument BooleXor */
  t10 = arg4 ^ arg1;
  goto g8124;

g8131:
  if (_trace) printf("g8131:\n");
  t1 = (t10 == Boole_Ior) ? 1 : 0;

g8149:
  if (_trace) printf("g8149:\n");
  if (t1 == 0)
    goto g8132;
  /* Here if argument BooleIor */
  t10 = arg4 | arg1;
  goto g8124;

g8132:
  if (_trace) printf("g8132:\n");
  t1 = (t10 == Boole_Nor) ? 1 : 0;

g8150:
  if (_trace) printf("g8150:\n");
  if (t1 == 0)
    goto g8133;
  /* Here if argument BooleNor */
  t10 = arg4 | arg1;
  t10 = ~t10;
  goto g8124;

g8133:
  if (_trace) printf("g8133:\n");
  t1 = (t10 == Boole_Equiv) ? 1 : 0;

g8151:
  if (_trace) printf("g8151:\n");
  if (t1 == 0)
    goto g8134;
  /* Here if argument BooleEquiv */
  t10 = arg4 ^ arg1;
  t10 = ~t10;
  goto g8124;

g8134:
  if (_trace) printf("g8134:\n");
  t1 = (t10 == Boole_C1) ? 1 : 0;

g8152:
  if (_trace) printf("g8152:\n");
  if (t1 == 0)
    goto g8135;
  /* Here if argument BooleC1 */
  t10 = ~arg4;
  goto g8124;

g8135:
  if (_trace) printf("g8135:\n");
  t1 = (t10 == Boole_OrC1) ? 1 : 0;

g8153:
  if (_trace) printf("g8153:\n");
  if (t1 == 0)
    goto g8136;
  /* Here if argument BooleOrC1 */
  t10 = arg1 | ~(arg4);
  goto g8124;

g8136:
  if (_trace) printf("g8136:\n");
  t1 = (t10 == Boole_C2) ? 1 : 0;

g8154:
  if (_trace) printf("g8154:\n");
  if (t1 == 0)
    goto g8137;
  /* Here if argument BooleC2 */
  t10 = ~arg1;
  goto g8124;

g8137:
  if (_trace) printf("g8137:\n");
  t1 = (t10 == Boole_OrC2) ? 1 : 0;

g8155:
  if (_trace) printf("g8155:\n");
  if (t1 == 0)
    goto g8138;
  /* Here if argument BooleOrC2 */
  t10 = arg4 & ~arg1;
  goto g8124;

g8138:
  if (_trace) printf("g8138:\n");
  t1 = (t10 == Boole_Nand) ? 1 : 0;

g8156:
  if (_trace) printf("g8156:\n");
  if (t1 == 0)
    goto g8139;
  /* Here if argument BooleNand */
  t10 = arg4 & arg1;
  goto g8124;

g8139:
  if (_trace) printf("g8139:\n");
  t1 = (t10 == Boole_Set) ? 1 : 0;

g8157:
  if (_trace) printf("g8157:\n");
  if (t1 == 0)
    goto g8124;
  /* Here if argument BooleSet */
  t10 = ~zero;

g8124:
  if (_trace) printf("g8124:\n");
  *(u32 *)iSP = t10;
  goto NEXTINSTRUCTION;

g8123:
  if (_trace) printf("g8123:\n");
  t1 = (arg5 == ALUFunction_Byte) ? 1 : 0;

g8183:
  if (_trace) printf("g8183:\n");
  if (t1 == 0)
    goto g8158;
  /* Here if argument ALUFunctionByte */
  /* Get rotate */
  t2 = *(u64 *)&(processor->byterotate);
  /* Get bytesize */
  t3 = *(u64 *)&(processor->bytesize);
  /* Get background */
  t1 = arg6 >> 10;
  /* Extract the byte background */
  t1 = t1 & 3;
  t4 = (t1 == ALUByteBackground_Op1) ? 1 : 0;

g8165:
  if (_trace) printf("g8165:\n");
  if (t4 == 0)
    goto g8161;
  /* Here if argument ALUByteBackgroundOp1 */
  t1 = arg4;

g8160:
  if (_trace) printf("g8160:\n");
  t5 = arg6 >> 12;
  /* Extractthe byte rotate latch */
  t5 = t5 & 1;
  t10 = arg1 << (t2 & 63);
  t4 = (u32)(t10 >> ((4&7)*8));
  t10 = (u32)t10;
  /* OP2 rotated */
  t10 = t10 | t4;
  /* Don't update rotate latch if not requested */
  if (t5 == 0)
    goto g8159;
  *(u64 *)&processor->rotatelatch = t10;

g8159:
  if (_trace) printf("g8159:\n");
  t5 = zero + -2;
  t5 = t5 << (t3 & 63);
  /* Compute mask */
  t5 = ~t5;
  /* Get byte function */
  t4 = arg6 >> 13;
  t4 = t4 & 1;
  t3 = (t4 == ALUByteFunction_Dpb) ? 1 : 0;

g8170:
  if (_trace) printf("g8170:\n");
  if (t3 == 0)
    goto g8167;
  /* Here if argument ALUByteFunctionDpb */
  /* Position mask */
  t5 = t5 << (t2 & 63);

g8166:
  if (_trace) printf("g8166:\n");
  /* rotated&mask */
  t10 = t10 & t5;
  /* background&~mask */
  t1 = t1 & ~t5;
  t10 = t10 | t1;
  *(u32 *)iSP = t10;
  goto NEXTINSTRUCTION;

g8158:
  if (_trace) printf("g8158:\n");
  t1 = (arg5 == ALUFunction_Adder) ? 1 : 0;

g8184:
  if (_trace) printf("g8184:\n");
  if (t1 == 0)
    goto g8171;
  /* Here if argument ALUFunctionAdder */
  t3 = arg6 >> 11;
  /* Extract the op2 */
  t3 = t3 & 3;
  t2 = arg6 >> 10;
  /* Extract the adder carry in */
  t2 = t2 & 1;
  t4 = (t3 == ALUAdderOp2_Op2) ? 1 : 0;

g8179:
  if (_trace) printf("g8179:\n");
  if (t4 == 0)
    goto g8174;
  /* Here if argument ALUAdderOp2Op2 */
  t1 = arg1;

g8173:
  if (_trace) printf("g8173:\n");
  t10 = arg4 + t1;
  t10 = t10 + t2;
  /* Sign bit */
  t3 = t10 >> 31;
  /* Next bit */
  t4 = t10 >> 32;
  /* Low bit is now overflow indicator */
  t3 = t3 ^ t4;
  /* Get the load-carry-in bit */
  t4 = arg6 >> 24;
  *(u64 *)&processor->aluoverflow = t3;
  if ((t4 & 1) == 0)
    goto g8172;
  /* Get the carry */
  t3 = (u32)(t10 >> ((4&7)*8));
  t4 = zero + 1024;
  arg6 = arg6 & ~t4;
  t4 = t3 & 1;
  t4 = t4 << 10;
  /* Set the adder carry in */
  arg6 = arg6 | t4;
  *(u64 *)&processor->aluandrotatecontrol = arg6;

g8172:
  if (_trace) printf("g8172:\n");
  t3 = ((s64)arg4 < (s64)t1) ? 1 : 0;
  *(u64 *)&processor->aluborrow = t3;
  arg4 = (s32)arg4;
  arg1 = (s32)arg1;
  t3 = ((s64)arg4 < (s64)t1) ? 1 : 0;
  *(u64 *)&processor->alulessthan = t3;
  *(u32 *)iSP = t10;
  goto NEXTINSTRUCTION;

g8171:
  if (_trace) printf("g8171:\n");
  t1 = (arg5 == ALUFunction_MultiplyDivide) ? 1 : 0;

g8185:
  if (_trace) printf("g8185:\n");
  if (t1 == 0)
    goto g8122;
  /* Here if argument ALUFunctionMultiplyDivide */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;
  *(u32 *)iSP = t10;
  goto NEXTINSTRUCTION;

g8122:
  if (_trace) printf("g8122:\n");

aluexc:
  if (_trace) printf("aluexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

g8174:
  if (_trace) printf("g8174:\n");
  t4 = (t3 == ALUAdderOp2_Zero) ? 1 : 0;

g8186:
  if (_trace) printf("g8186:\n");
  if (t4 == 0)
    goto g8175;
  /* Here if argument ALUAdderOp2Zero */
  t1 = zero;
  goto g8173;

g8175:
  if (_trace) printf("g8175:\n");
  t4 = (t3 == ALUAdderOp2_Invert) ? 1 : 0;

g8187:
  if (_trace) printf("g8187:\n");
  if (t4 == 0)
    goto g8176;
  /* Here if argument ALUAdderOp2Invert */
  t1 = (s32)arg1;
  t1 = zero - t1;
  t1 = (u32)t1;
  goto g8173;

g8176:
  if (_trace) printf("g8176:\n");
  t4 = (t3 == ALUAdderOp2_MinusOne) ? 1 : 0;

g8188:
  if (_trace) printf("g8188:\n");
  if (t4 == 0)
    goto g8173;
  /* Here if argument ALUAdderOp2MinusOne */
  t1 = ~zero;
  t1 = (u32)t1;
  goto g8173;

g8167:
  if (_trace) printf("g8167:\n");
  t3 = (t4 == ALUByteFunction_Ldb) ? 1 : 0;

g8189:
  if (_trace) printf("g8189:\n");
  if (t3 != 0)
    goto g8166;
  goto g8166;

g8161:
  if (_trace) printf("g8161:\n");
  t4 = (t1 == ALUByteBackground_RotateLatch) ? 1 : 0;

g8190:
  if (_trace) printf("g8190:\n");
  if (t4 == 0)
    goto g8162;
  /* Here if argument ALUByteBackgroundRotateLatch */
  t1 = *(u64 *)&(processor->rotatelatch);
  goto g8160;

g8162:
  if (_trace) printf("g8162:\n");
  t4 = (t1 == ALUByteBackground_Zero) ? 1 : 0;

g8191:
  if (_trace) printf("g8191:\n");
  if (t4 == 0)
    goto g8160;
  /* Here if argument ALUByteBackgroundZero */
  t1 = zero;
  goto g8160;

/* end DoAlu */
  /* End of Halfword operand from stack instruction - DoAlu */
/* start DoSpareOp */

  /* Halfword 10 bit immediate instruction - DoSpareOp */

dospareop:
  if (_trace) printf("dospareop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoSpareOpIM:
  if (_trace) printf("DoSpareOpIM:\n");

DoSpareOpSP:
  if (_trace) printf("DoSpareOpSP:\n");

DoSpareOpLP:
  if (_trace) printf("DoSpareOpLP:\n");

DoSpareOpFP:
  if (_trace) printf("DoSpareOpFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  /* Get the instruction */
  t1 = *(u64 *)&(((CACHELINEP)iCP)->instruction);
  /* Position the opcode */
  t1 = t1 >> 10;
  /* Extract it */
  t1 = t1 & 255;
  /* arg1 = instruction arity */
  arg1 = 0;
  /* arg2 = instruction opcode */
  arg2 = t1;
  /* arg3 = stackp */
  arg3 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  /* when not stackp arg5=the arg */
  arg5 = 0;
  /* arg6=tag to dispatch on */
  arg6 = 0;
  goto exception;
  goto NEXTINSTRUCTION;

/* end DoSpareOp */
  /* End of Halfword operand from stack instruction - DoSpareOp */
  /* Reading and writing internal registers */
/* start ReadRegisterFP */


ReadRegisterFP:
  if (_trace) printf("ReadRegisterFP:\n");
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);
  t4 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t5 = iFP - t5;
  /* convert byte address to word address */
  t5 = t5 >> 3;
  /* reconstruct VMA */
  t4 = t5 + t4;
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterFP */
/* start ReadRegisterLP */


ReadRegisterLP:
  if (_trace) printf("ReadRegisterLP:\n");
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);
  t4 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t5 = iLP - t5;
  /* convert byte address to word address */
  t5 = t5 >> 3;
  /* reconstruct VMA */
  t4 = t5 + t4;
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterLP */
/* start ReadRegisterSP */


ReadRegisterSP:
  if (_trace) printf("ReadRegisterSP:\n");
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);
  t4 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t5 = iSP - t5;
  /* convert byte address to word address */
  t5 = t5 >> 3;
  /* reconstruct VMA */
  t4 = t5 + t4;
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterSP */
/* start ReadRegisterStackCacheLowerBound */


ReadRegisterStackCacheLowerBound:
  if (_trace) printf("ReadRegisterStackCacheLowerBound:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterStackCacheLowerBound */
/* start ReadRegisterBARx */


ReadRegisterBARx:
  if (_trace) printf("ReadRegisterBARx:\n");
  /* BAR number into T2 */
  t2 = arg1 >> 7;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t1 = (u64)&processor->bar0;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Now T1 points to the BAR */
  t1 = (t2 * 8) + t1;
  t3 = *(u64 *)t1;
  t4 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto cachevalid;

/* end ReadRegisterBARx */
/* start ReadRegisterContinuation */


ReadRegisterContinuation:
  if (_trace) printf("ReadRegisterContinuation:\n");
  t3 = *(u64 *)&(processor->continuation);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterContinuation */
/* start ReadRegisterAluAndRotateControl */


ReadRegisterAluAndRotateControl:
  if (_trace) printf("ReadRegisterAluAndRotateControl:\n");
  t3 = *(u64 *)&(processor->aluandrotatecontrol);
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterAluAndRotateControl */
/* start ReadRegisterControlRegister */


ReadRegisterControlRegister:
  if (_trace) printf("ReadRegisterControlRegister:\n");
  t3 = *(s32 *)&processor->control;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterControlRegister */
/* start ReadRegisterCRArgumentSize */


ReadRegisterCRArgumentSize:
  if (_trace) printf("ReadRegisterCRArgumentSize:\n");
  t3 = *(s32 *)&processor->control;
  /* Get the argument size field */
  t3 = t3 & 255;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterCRArgumentSize */
/* start ReadRegisterEphemeralOldspaceRegister */


ReadRegisterEphemeralOldspaceRegister:
  if (_trace) printf("ReadRegisterEphemeralOldspaceRegister:\n");
  t3 = *(s32 *)&processor->ephemeraloldspace;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterEphemeralOldspaceRegister */
/* start ReadRegisterZoneOldspaceRegister */


ReadRegisterZoneOldspaceRegister:
  if (_trace) printf("ReadRegisterZoneOldspaceRegister:\n");
  t3 = *(s32 *)&processor->zoneoldspace;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterZoneOldspaceRegister */
/* start ReadRegisterChipRevision */


ReadRegisterChipRevision:
  if (_trace) printf("ReadRegisterChipRevision:\n");
  t3 = 5;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterChipRevision */
/* start ReadRegisterFPCoprocessorPresent */


ReadRegisterFPCoprocessorPresent:
  if (_trace) printf("ReadRegisterFPCoprocessorPresent:\n");
  t4 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterFPCoprocessorPresent */
/* start ReadRegisterPreemptRegister */


ReadRegisterPreemptRegister:
  if (_trace) printf("ReadRegisterPreemptRegister:\n");
  t3 = *(s32 *)&processor->interruptreg;
  t3 = t3 & 3;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterPreemptRegister */
/* start ReadRegisterIcacheControl */


ReadRegisterIcacheControl:
  if (_trace) printf("ReadRegisterIcacheControl:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterIcacheControl */
/* start ReadRegisterPrefetcherControl */


ReadRegisterPrefetcherControl:
  if (_trace) printf("ReadRegisterPrefetcherControl:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterPrefetcherControl */
/* start ReadRegisterMapCacheControl */


ReadRegisterMapCacheControl:
  if (_trace) printf("ReadRegisterMapCacheControl:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterMapCacheControl */
/* start ReadRegisterMemoryControl */


ReadRegisterMemoryControl:
  if (_trace) printf("ReadRegisterMemoryControl:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterMemoryControl */
/* start ReadRegisterStackCacheOverflowLimit */


ReadRegisterStackCacheOverflowLimit:
  if (_trace) printf("ReadRegisterStackCacheOverflowLimit:\n");
  t3 = *(s32 *)&processor->scovlimit;
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t3 = t3 + t4;
  t4 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterStackCacheOverflowLimit */
/* start ReadRegisterMicrosecondClock */


ReadRegisterMicrosecondClock:
  if (_trace) printf("ReadRegisterMicrosecondClock:\n");
  t1 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterMicrosecondClock */
/* start ReadRegisterTOS */


ReadRegisterTOS:
  if (_trace) printf("ReadRegisterTOS:\n");
  t1 = *(u64 *)iSP;
  iSP = iSP + 8;
  t2 = t1 << 26;
  t2 = t2 >> 26;
  /* Push CDR-NEXT TOS */
  *(u64 *)iSP = t2;
  goto NEXTINSTRUCTION;

/* end ReadRegisterTOS */
/* start ReadRegisterEventCount */


ReadRegisterEventCount:
  if (_trace) printf("ReadRegisterEventCount:\n");
  t3 = *(u64 *)&(processor->areventcount);
  t4 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterEventCount */
/* start ReadRegisterBindingStackPointer */


ReadRegisterBindingStackPointer:
  if (_trace) printf("ReadRegisterBindingStackPointer:\n");
  t3 = *(u64 *)&(processor->bindingstackpointer);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterBindingStackPointer */
/* start ReadRegisterCatchBlockList */


ReadRegisterCatchBlockList:
  if (_trace) printf("ReadRegisterCatchBlockList:\n");
  t3 = *(u64 *)&(processor->catchblock);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterCatchBlockList */
/* start ReadRegisterControlStackLimit */


ReadRegisterControlStackLimit:
  if (_trace) printf("ReadRegisterControlStackLimit:\n");
  t3 = *(s32 *)&processor->cslimit;
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterControlStackLimit */
/* start ReadRegisterControlStackExtraLimit */


ReadRegisterControlStackExtraLimit:
  if (_trace) printf("ReadRegisterControlStackExtraLimit:\n");
  t3 = *(s32 *)&processor->csextralimit;
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterControlStackExtraLimit */
/* start ReadRegisterBindingStackLimit */


ReadRegisterBindingStackLimit:
  if (_trace) printf("ReadRegisterBindingStackLimit:\n");
  t3 = *(u64 *)&(processor->bindingstacklimit);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterBindingStackLimit */
/* start ReadRegisterPHTBase */


ReadRegisterPHTBase:
  if (_trace) printf("ReadRegisterPHTBase:\n");
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterPHTBase */
/* start ReadRegisterPHTMask */


ReadRegisterPHTMask:
  if (_trace) printf("ReadRegisterPHTMask:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterPHTMask */
/* start ReadRegisterCountMapReloads */


ReadRegisterCountMapReloads:
  if (_trace) printf("ReadRegisterCountMapReloads:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterCountMapReloads */
/* start ReadRegisterListCacheArea */


ReadRegisterListCacheArea:
  if (_trace) printf("ReadRegisterListCacheArea:\n");
  t3 = *(u64 *)&(processor->lcarea);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterListCacheArea */
/* start ReadRegisterListCacheAddress */


ReadRegisterListCacheAddress:
  if (_trace) printf("ReadRegisterListCacheAddress:\n");
  t3 = *(u64 *)&(processor->lcaddress);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterListCacheAddress */
/* start ReadRegisterListCacheLength */


ReadRegisterListCacheLength:
  if (_trace) printf("ReadRegisterListCacheLength:\n");
  t3 = *(s32 *)&processor->lclength;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterListCacheLength */
/* start ReadRegisterStructureCacheArea */


ReadRegisterStructureCacheArea:
  if (_trace) printf("ReadRegisterStructureCacheArea:\n");
  t3 = *(u64 *)&(processor->scarea);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterStructureCacheArea */
/* start ReadRegisterStructureCacheAddress */


ReadRegisterStructureCacheAddress:
  if (_trace) printf("ReadRegisterStructureCacheAddress:\n");
  t3 = *(u64 *)&(processor->scaddress);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterStructureCacheAddress */
/* start ReadRegisterStructureCacheLength */


ReadRegisterStructureCacheLength:
  if (_trace) printf("ReadRegisterStructureCacheLength:\n");
  t3 = *(s32 *)&processor->sclength;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterStructureCacheLength */
/* start ReadRegisterDynamicBindingCacheBase */


ReadRegisterDynamicBindingCacheBase:
  if (_trace) printf("ReadRegisterDynamicBindingCacheBase:\n");
  t3 = *(u64 *)&(processor->dbcbase);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterDynamicBindingCacheBase */
/* start ReadRegisterDynamicBindingCacheMask */


ReadRegisterDynamicBindingCacheMask:
  if (_trace) printf("ReadRegisterDynamicBindingCacheMask:\n");
  t3 = *(u64 *)&(processor->dbcmask);
  iSP = iSP + 8;
  t5 = t3 << 26;
  t5 = t5 >> 26;
  *(u64 *)iSP = t5;
  goto NEXTINSTRUCTION;

/* end ReadRegisterDynamicBindingCacheMask */
/* start ReadRegisterChoicePointer */


ReadRegisterChoicePointer:
  if (_trace) printf("ReadRegisterChoicePointer:\n");
  t3 = *(s32 *)&processor->choiceptr;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterChoicePointer */
/* start ReadRegisterStructureStackChoicePointer */


ReadRegisterStructureStackChoicePointer:
  if (_trace) printf("ReadRegisterStructureStackChoicePointer:\n");
  t3 = *(s32 *)&processor->sstkchoiceptr;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterStructureStackChoicePointer */
/* start ReadRegisterFEPModeTrapVectorAddress */


ReadRegisterFEPModeTrapVectorAddress:
  if (_trace) printf("ReadRegisterFEPModeTrapVectorAddress:\n");
  t3 = *(u64 *)&(processor->fepmodetrapvecaddress);
  goto NEXTINSTRUCTION;

/* end ReadRegisterFEPModeTrapVectorAddress */
/* start ReadRegisterStackFrameMaximumSize */


ReadRegisterStackFrameMaximumSize:
  if (_trace) printf("ReadRegisterStackFrameMaximumSize:\n");
  t3 = zero + 128;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterStackFrameMaximumSize */
/* start ReadRegisterStackCacheDumpQuantum */


ReadRegisterStackCacheDumpQuantum:
  if (_trace) printf("ReadRegisterStackCacheDumpQuantum:\n");
  t3 = zero + 896;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterStackCacheDumpQuantum */
/* start ReadRegisterConstantNIL */


ReadRegisterConstantNIL:
  if (_trace) printf("ReadRegisterConstantNIL:\n");
  t5 = *(u64 *)&(processor->taddress);
  /* push the data */
  *(u64 *)(iSP + 8) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterConstantNIL */
/* start ReadRegisterConstantT */


ReadRegisterConstantT:
  if (_trace) printf("ReadRegisterConstantT:\n");
  t5 = *(u64 *)&(processor->niladdress);
  /* push the data */
  *(u64 *)(iSP + 8) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

/* end ReadRegisterConstantT */
/* start ReadRegisterError */


ReadRegisterError:
  if (_trace) printf("ReadRegisterError:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

/* end ReadRegisterError */
/* start WriteRegisterFP */


WriteRegisterFP:
  if (_trace) printf("WriteRegisterFP:\n");
#ifdef IVERIFY
  /* Base of the stack cache */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t1 = *(s32 *)&processor->scovlimit;
  /* Stack cache offset */
  t2 = arg3 - t2;
  /* In range? */
  t3 = ((u64)t2 < (u64)t1) ? 1 : 0;
  t1 = *(u64 *)&(processor->stackcachedata);
  /* J. if not in cache */
  if (t3 == 0)
    goto badregister;
  /* reconstruct SCA */
  t1 = (t2 * 8) + t1;
  iFP = t1;
  goto NEXTINSTRUCTION;
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;
#endif

/* end WriteRegisterFP */
/* start WriteRegisterLP */


WriteRegisterLP:
  if (_trace) printf("WriteRegisterLP:\n");
#ifdef IVERIFY
  /* Base of the stack cache */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t1 = *(s32 *)&processor->scovlimit;
  /* Stack cache offset */
  t2 = arg3 - t2;
  /* In range? */
  t3 = ((u64)t2 < (u64)t1) ? 1 : 0;
  t1 = *(u64 *)&(processor->stackcachedata);
  /* J. if not in cache */
  if (t3 == 0)
    goto badregister;
  /* reconstruct SCA */
  t1 = (t2 * 8) + t1;
  iLP = t1;
  goto NEXTINSTRUCTION;
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;
#endif

/* end WriteRegisterLP */
/* start WriteRegisterSP */


WriteRegisterSP:
  if (_trace) printf("WriteRegisterSP:\n");
#ifdef IVERIFY
  /* Base of the stack cache */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t1 = *(s32 *)&processor->scovlimit;
  /* Stack cache offset */
  t2 = arg3 - t2;
  /* In range? */
  t3 = ((u64)t2 < (u64)t1) ? 1 : 0;
  t1 = *(u64 *)&(processor->stackcachedata);
  /* J. if not in cache */
  if (t3 == 0)
    goto badregister;
  /* reconstruct SCA */
  t1 = (t2 * 8) + t1;
  iSP = t1;
  goto NEXTINSTRUCTION;
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;
#endif

/* end WriteRegisterSP */
/* start WriteRegisterStackCacheLowerBound */


WriteRegisterStackCacheLowerBound:
  if (_trace) printf("WriteRegisterStackCacheLowerBound:\n");
#ifdef IVERIFY
  *(u64 *)&processor->stackcachebasevma = arg3;
  t1 = *(u64 *)&(processor->stackcachesize);
  t1 = arg3 + t1;
  *(u64 *)&processor->stackcachetopvma = t1;
  goto NEXTINSTRUCTION;
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;
#endif

/* end WriteRegisterStackCacheLowerBound */
/* start WriteRegisterContinuation */


WriteRegisterContinuation:
  if (_trace) printf("WriteRegisterContinuation:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->continuation = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterContinuation */
/* start WriteRegisterAluAndRotateControl */


WriteRegisterAluAndRotateControl:
  if (_trace) printf("WriteRegisterAluAndRotateControl:\n");
  t1 = arg3 >> 14;
  /* Extract the function class bits */
  t1 = t1 & 3;
  *(u64 *)&processor->aluandrotatecontrol = arg3;
  t2 = arg3 >> 5;
  /* Extract the byte size */
  t2 = t2 & 31;
  *(u64 *)&processor->aluop = t1;
  /* Extract the Byte Rotate */
  t3 = arg3 & 31;
  *(u64 *)&processor->bytesize = t2;
  *(u64 *)&processor->byterotate = t3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterAluAndRotateControl */
/* start WriteRegisterControlRegister */


WriteRegisterControlRegister:
  if (_trace) printf("WriteRegisterControlRegister:\n");
  *(u32 *)&processor->control = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterControlRegister */
/* start WriteRegisterEphemeralOldspaceRegister */


WriteRegisterEphemeralOldspaceRegister:
  if (_trace) printf("WriteRegisterEphemeralOldspaceRegister:\n");
  *(u64 *)&processor->ac0array = zero;
  *(u64 *)&processor->ac1array = zero;
  *(u64 *)&processor->ac2array = zero;
  *(u64 *)&processor->ac3array = zero;
  *(u64 *)&processor->ac4array = zero;
  *(u64 *)&processor->ac5array = zero;
  *(u64 *)&processor->ac6array = zero;
  *(u64 *)&processor->ac7array = zero;
  *(u32 *)&processor->ephemeraloldspace = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterEphemeralOldspaceRegister */
/* start WriteRegisterZoneOldspaceRegister */


WriteRegisterZoneOldspaceRegister:
  if (_trace) printf("WriteRegisterZoneOldspaceRegister:\n");
  *(u32 *)&processor->zoneoldspace = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterZoneOldspaceRegister */
/* start WriteRegisterFPCoprocessorPresent */


WriteRegisterFPCoprocessorPresent:
  if (_trace) printf("WriteRegisterFPCoprocessorPresent:\n");
  goto NEXTINSTRUCTION;

/* end WriteRegisterFPCoprocessorPresent */
/* start WriteRegisterPreemptRegister */


WriteRegisterPreemptRegister:
  if (_trace) printf("WriteRegisterPreemptRegister:\n");
  t3 = *(s32 *)&processor->interruptreg;
  t3 = t3 & ~3L;
  arg3 = arg3 & 3;
  t3 = t3 | arg3;
  *(u32 *)&processor->interruptreg = t3;
  if ((t3 & 1) == 0)
    goto NEXTINSTRUCTION;
  *(u64 *)&processor->stop_interpreter = t3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterPreemptRegister */
/* start WriteRegisterStackCacheOverflowLimit */


WriteRegisterStackCacheOverflowLimit:
  if (_trace) printf("WriteRegisterStackCacheOverflowLimit:\n");
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t1 = (u32)t1;
  t1 = arg3 - t1;
  *(u32 *)&processor->scovlimit = t1;
  goto NEXTINSTRUCTION;

/* end WriteRegisterStackCacheOverflowLimit */
/* start WriteRegisterTOS */


WriteRegisterTOS:
  if (_trace) printf("WriteRegisterTOS:\n");
  goto NEXTINSTRUCTION;

/* end WriteRegisterTOS */
/* start WriteRegisterEventCount */


WriteRegisterEventCount:
  if (_trace) printf("WriteRegisterEventCount:\n");
  *(u64 *)&processor->areventcount = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterEventCount */
/* start WriteRegisterBindingStackPointer */


WriteRegisterBindingStackPointer:
  if (_trace) printf("WriteRegisterBindingStackPointer:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->bindingstackpointer = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterBindingStackPointer */
/* start WriteRegisterCatchBlockList */


WriteRegisterCatchBlockList:
  if (_trace) printf("WriteRegisterCatchBlockList:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->catchblock = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterCatchBlockList */
/* start WriteRegisterControlStackLimit */


WriteRegisterControlStackLimit:
  if (_trace) printf("WriteRegisterControlStackLimit:\n");
  *(u32 *)&processor->cslimit = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterControlStackLimit */
/* start WriteRegisterControlStackExtraLimit */


WriteRegisterControlStackExtraLimit:
  if (_trace) printf("WriteRegisterControlStackExtraLimit:\n");
  *(u32 *)&processor->csextralimit = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterControlStackExtraLimit */
/* start WriteRegisterBindingStackLimit */


WriteRegisterBindingStackLimit:
  if (_trace) printf("WriteRegisterBindingStackLimit:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->bindingstacklimit = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterBindingStackLimit */
/* start WriteRegisterListCacheArea */


WriteRegisterListCacheArea:
  if (_trace) printf("WriteRegisterListCacheArea:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->lcarea = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterListCacheArea */
/* start WriteRegisterListCacheAddress */


WriteRegisterListCacheAddress:
  if (_trace) printf("WriteRegisterListCacheAddress:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->lcaddress = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterListCacheAddress */
/* start WriteRegisterListCacheLength */


WriteRegisterListCacheLength:
  if (_trace) printf("WriteRegisterListCacheLength:\n");
  *(u32 *)&processor->lclength = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterListCacheLength */
/* start WriteRegisterStructureCacheArea */


WriteRegisterStructureCacheArea:
  if (_trace) printf("WriteRegisterStructureCacheArea:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->scarea = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterStructureCacheArea */
/* start WriteRegisterStructureCacheAddress */


WriteRegisterStructureCacheAddress:
  if (_trace) printf("WriteRegisterStructureCacheAddress:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->scaddress = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterStructureCacheAddress */
/* start WriteRegisterStructureCacheLength */


WriteRegisterStructureCacheLength:
  if (_trace) printf("WriteRegisterStructureCacheLength:\n");
  *(u32 *)&processor->sclength = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterStructureCacheLength */
/* start WriteRegisterDynamicBindingCacheBase */


WriteRegisterDynamicBindingCacheBase:
  if (_trace) printf("WriteRegisterDynamicBindingCacheBase:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->dbcbase = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterDynamicBindingCacheBase */
/* start WriteRegisterDynamicBindingCacheMask */


WriteRegisterDynamicBindingCacheMask:
  if (_trace) printf("WriteRegisterDynamicBindingCacheMask:\n");
  arg4 = arg2 << 32;
  /* construct the combined word */
  arg4 = arg4 | arg3;
  *(u64 *)&processor->dbcmask = arg4;
  goto NEXTINSTRUCTION;

/* end WriteRegisterDynamicBindingCacheMask */
/* start WriteRegisterChoicePointer */


WriteRegisterChoicePointer:
  if (_trace) printf("WriteRegisterChoicePointer:\n");
  *(u32 *)&processor->choiceptr = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterChoicePointer */
/* start WriteRegisterStructureStackChoicePointer */


WriteRegisterStructureStackChoicePointer:
  if (_trace) printf("WriteRegisterStructureStackChoicePointer:\n");
  *(u32 *)&processor->sstkchoiceptr = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterStructureStackChoicePointer */
/* start WriteRegisterFEPModeTrapVectorAddress */


WriteRegisterFEPModeTrapVectorAddress:
  if (_trace) printf("WriteRegisterFEPModeTrapVectorAddress:\n");
  *(u32 *)&processor->fepmodetrapvecaddress = arg3;
  goto NEXTINSTRUCTION;

/* end WriteRegisterFEPModeTrapVectorAddress */
/* start WriteRegisterMappingTableCache */


WriteRegisterMappingTableCache:
  if (_trace) printf("WriteRegisterMappingTableCache:\n");
  goto NEXTINSTRUCTION;

/* end WriteRegisterMappingTableCache */
/* start WriteRegisterError */


WriteRegisterError:
  if (_trace) printf("WriteRegisterError:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

/* end WriteRegisterError */
  /* Coprocessor read and write are implemented in C in order to */
  /* encourage creativity!  The hooks are in aicoproc.c */
/* start DoCoprocessorRead */

  /* Halfword 10 bit immediate instruction - DoCoprocessorRead */

docoprocessorread:
  if (_trace) printf("docoprocessorread:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoCoprocessorReadIM:
  if (_trace) printf("DoCoprocessorReadIM:\n");

DoCoprocessorReadSP:
  if (_trace) printf("DoCoprocessorReadSP:\n");

DoCoprocessorReadLP:
  if (_trace) printf("DoCoprocessorReadLP:\n");

DoCoprocessorReadFP:
  if (_trace) printf("DoCoprocessorReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  r0 = *(u64 *)&(processor->coprocessorreadhook);
  *(u64 *)&processor->cp = iCP;
  *(u64 *)&processor->epc = iPC;
  *(u64 *)&processor->sp = iSP;
  *(u64 *)&processor->fp = iFP;
  *(u64 *)&processor->lp = iLP;
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  pv = r0;
    r0 = (*( u64 (*)(u64, u64) )r0)(arg1, arg2); /* jsr */
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  iCP = *(u64 *)&(processor->cp);
  iPC = *(u64 *)&(processor->epc);
  iSP = *(u64 *)&(processor->sp);
  iFP = *(u64 *)&(processor->fp);
  iLP = *(u64 *)&(processor->lp);
  /* Long -1 is never a valid LISP value */
  t1 = zero + -1;
  t1 = (r0 == t1) ? 1 : 0;
  /* J. if CoprocessorRead exception return */
  if (t1 != 0)
    goto cpreadexc;
  iSP = iSP + 8;
  t1 = r0 << 26;
  t1 = t1 >> 26;
  /* Push the result of coprocessor read! */
  *(u64 *)iSP = t1;
  goto NEXTINSTRUCTION;

cpreadexc:
  if (_trace) printf("cpreadexc:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

/* end DoCoprocessorRead */
  /* End of Halfword operand from stack instruction - DoCoprocessorRead */
/* start DoCoprocessorWrite */

  /* Halfword 10 bit immediate instruction - DoCoprocessorWrite */

docoprocessorwrite:
  if (_trace) printf("docoprocessorwrite:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoCoprocessorWriteIM:
  if (_trace) printf("DoCoprocessorWriteIM:\n");

DoCoprocessorWriteSP:
  if (_trace) printf("DoCoprocessorWriteSP:\n");

DoCoprocessorWriteLP:
  if (_trace) printf("DoCoprocessorWriteLP:\n");

DoCoprocessorWriteFP:
  if (_trace) printf("DoCoprocessorWriteFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  /* The value to be written */
  arg2 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  t2 = zero + CoprocessorRegister_UnwindStackForRestartOrApply;
  t2 = arg1 - t2;
  if (t2 != 0)
    goto g8194;
  /* Here if argument CoprocessorRegisterUnwindStackForRestartOrApply */
  /* peek at new continuation to look at tag */
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  t3 = t2 - Type_EvenPC;
  /* Strip CDR code, low bits */
  t3 = t3 & 62;
  if (t3 != 0)
    goto unwindillegalcontinuation;
  /* Get new continuation */
  t1 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  /* Update continuation register */
  *(u64 *)&processor->continuation = t1;
  *(u64 *)&processor->continuationcp = zero;
  /* Get new FP */
  t1 = *(s32 *)iSP;
  /* Get new FP */
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  t3 = t2 - Type_Locative;
  /* Strip CDR code */
  t3 = t3 & 63;
  if (t3 != 0)
    goto unwindillegalfp;
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  iFP = *(u64 *)&(processor->stackcachedata);
  /* stack cache base relative offset */
  t2 = t1 - t2;
  /* reconstruct SCA */
  iFP = (t2 * 8) + iFP;
  /* Get new LP */
  t1 = *(s32 *)iSP;
  /* Get new LP */
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  t3 = t2 - Type_Locative;
  /* Strip CDR code */
  t3 = t3 & 63;
  if (t3 != 0)
    goto unwindillegallp;
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  iLP = *(u64 *)&(processor->stackcachedata);
  /* stack cache base relative offset */
  t2 = t1 - t2;
  /* reconstruct SCA */
  iLP = (t2 * 8) + iLP;
  /* Update CDR-CODEs to make it a legitimate frame */
  /* Tag of saved continuation register */
  t1 = *(s32 *)(iFP + 4);
  /* Tag of saved control register */
  t2 = *(s32 *)(iFP + 12);
  /* Set CDR-CODE to 3 */
  t1 = t1 | 192;
  /* Put it back */
  *(u32 *)(iFP + 4) = t1;
  /* Set CDR-CODE to 3 */
  t2 = t2 | 192;
  /* Put it back */
  *(u32 *)(iFP + 12) = t2;
  /* Copy the current trap-on-exit bit into the saved control register */
  /* Get control register */
  t1 = *(s32 *)&processor->control;
  /* Get saved control register */
  t2 = *(s32 *)(iFP + 8);
  t2 = (u32)t2;
  t3 = (256) << 16;
  /* Remove saved control register's trap-on-exit bit */
  t2 = t2 & ~t3;
  /* Extract control register's trap-on-exit bit */
  t1 = t1 & t3;
  /* Copy it into saved control register */
  t2 = t2 | t1;
  /* Update saved control register */
  *(u32 *)(iFP + 8) = t2;
  /* Restore the new control register with proper trap mode */
  /* peek at new control register to look at tag */
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  t3 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t3 = t3 & 63;
  if (t3 != 0)
    goto unwindillegalcontrol;
  /* Get new control register */
  t1 = *(s32 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  *(u32 *)&processor->control = t1;
  goto g8193;

g8194:
  if (_trace) printf("g8194:\n");
  t2 = zero + CoprocessorRegister_FlushIDCaches;
  t2 = arg1 - t2;
  if (t2 != 0)
    goto g8195;
  /* Here if argument CoprocessorRegisterFlushIDCaches */
  /* We're about to flush the instruction cache so we can't rely */
  /* on ContinueToNextInstruction working.  Instead, we must load */
  /* the next PC now and explicitly fill the cache. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t1 = *(u64 *)&(processor->flushcaches_hook);
  *(u64 *)&processor->cp = iCP;
  *(u64 *)&processor->epc = iPC;
  *(u64 *)&processor->sp = iSP;
  *(u64 *)&processor->fp = iFP;
  *(u64 *)&processor->lp = iLP;
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  pv = t1;
    r0 = (*( u64 (*)(u64, u64) )t1)(arg1, arg2); /* jsr */
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  iCP = *(u64 *)&(processor->cp);
  iPC = *(u64 *)&(processor->epc);
  iSP = *(u64 *)&(processor->sp);
  iFP = *(u64 *)&(processor->fp);
  iLP = *(u64 *)&(processor->lp);
  /* Compute proper iCP after FlushCaches resets it. */
  goto ICACHEMISS;
  goto g8193;

g8195:
  if (_trace) printf("g8195:\n");
  t2 = zero + CoprocessorRegister_FlushCachesForVMA;
  t2 = arg1 - t2;
  if (t2 != 0)
    goto g8196;
  /* Here if argument CoprocessorRegisterFlushCachesForVMA */
  /* Extract the VMA */
  arg2 = (u32)arg2;
  /* convert continuation to an even pc */
  t1 = arg2 << 1;
  /* Convert a halfword address into a CP pointer. */
  /* Get third byte into bottom */
  t2 = t1 >> (CacheLine_RShift & 63);
  /* get the base of the icache */
  t4 = *(u64 *)&(processor->icachebase);
  t3 = zero + -1;
  t3 = t3 + ((4) << 16);
  /* Now third byte is zero-shifted */
  t2 = t2 << (CacheLine_LShift & 63);
  t2 = t1 + t2;
  t2 = t2 & t3;
  /* temp=cpos*32 */
  t3 = t2 << 5;
  /* cpos=cpos*16 */
  t2 = t2 << 4;
  /* temp2=base+cpos*32 */
  t4 = t4 + t3;
  /* cpos=base+cpos*48 */
  t2 = t4 + t2;
  t3 = *(u64 *)&(((CACHELINEP)t2)->pcdata);
  /* Is this VMA in the cache? */
  t3 = (t1 == t3) ? 1 : 0;
  /* No. */
  if (t3 == 0)
    goto dcwnotincache;
  /* Yes, flush it */
  *(u64 *)&((CACHELINEP)t2)->pcdata = zero;
  *((u64 *)(&((CACHELINEP)t2)->pcdata)+CACHELINESIZE/8) = zero;

dcwnotincache:
  if (_trace) printf("dcwnotincache:\n");
  goto g8193;

g8196:
  if (_trace) printf("g8196:\n");
  t2 = zero + CoprocessorRegister_FlushHiddenArrayRegisters;
  t2 = arg1 - t2;
  if (t2 != 0)
    goto g8197;
  /* Here if argument CoprocessorRegisterFlushHiddenArrayRegisters */
  /* Get the VMA of the new stack array */
  arg2 = (u32)arg2;
  t8 = zero + AutoArrayRegMask;
  t8 = arg2 & t8;
  t7 = (u64)&processor->ac0array;
  /* Here is our array register block */
  t7 = t7 + t8;
  /* And here is the cached array */
  t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array);
  /* t8==1 iff cached array is ours */
  t8 = (arg2 == t8) ? 1 : 0;
  if (t8 == 0)
    goto arraynotincache;
  /* Flush it */
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;

arraynotincache:
  if (_trace) printf("arraynotincache:\n");
  goto g8193;

g8197:
  if (_trace) printf("g8197:\n");
  /* Here for all other cases */
  /* Standard coprocessor register processing */
  r0 = *(u64 *)&(processor->coprocessorwritehook);
  *(u64 *)&processor->cp = iCP;
  *(u64 *)&processor->epc = iPC;
  *(u64 *)&processor->sp = iSP;
  *(u64 *)&processor->fp = iFP;
  *(u64 *)&processor->lp = iLP;
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  pv = r0;
    r0 = (*( u64 (*)(u64, u64) )r0)(arg1, arg2); /* jsr */
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  iCP = *(u64 *)&(processor->cp);
  iPC = *(u64 *)&(processor->epc);
  iSP = *(u64 *)&(processor->sp);
  iFP = *(u64 *)&(processor->fp);
  iLP = *(u64 *)&(processor->lp);
  /* J. if CoprocessorWrite exception return */
  if (r0 == 0)
    goto cpreadexc;
  goto g8193;

g8198:
  if (_trace) printf("g8198:\n");

g8193:
  if (_trace) printf("g8193:\n");
  goto NEXTINSTRUCTION;

unwindillegalcontinuation:
  if (_trace) printf("unwindillegalcontinuation:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

unwindillegalcontrol:
  if (_trace) printf("unwindillegalcontrol:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

unwindillegalfp:
  if (_trace) printf("unwindillegalfp:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

unwindillegallp:
  if (_trace) printf("unwindillegallp:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

cpwriteexc:
  if (_trace) printf("cpwriteexc:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

/* end DoCoprocessorWrite */
  /* End of Halfword operand from stack instruction - DoCoprocessorWrite */
/* start GetRPCC */


getrpcc:
  if (_trace) printf("getrpcc:\n");
  r0 = RPCC();
  arg1 = r0 << 32;
  arg1 = r0 + arg1;
  r0 = arg1 >> 32;
  goto *ra; /* ret */

/* end GetRPCC */
/* start SpinWheels */


spinwheels:
  if (_trace) printf("spinwheels:\n");
  arg1 = 1;
  arg1 = arg1 << 25;

spinwheelaxis:
  if (_trace) printf("spinwheelaxis:\n");
  arg1 = arg1 + -1;
  if ((s64)arg1 > 0)
    goto spinwheelaxis;
  goto *ra; /* ret */

/* end SpinWheels */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunsubp.as */
