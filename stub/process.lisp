;;
;; convert alpha assembler lisp into C
;; I may never live this down, but I had to try it...
;;
;; Brad Parker 4/2006
;; brad@heeltoe.com
;;

(progn
  (defmacro unlock-package (pack)
    (setf *locked-package-saved-value* (ext:package-lock pack)
	  (ext:package-lock pack) nil))

  (unlock-package system)
  (unlock-package common-lisp)
  (unlock-package clos)
)

(unlock-package system)

(defpackage ALPHA-AXP-INTERNALS
  (:nicknames AXPI)
  (:use COMMON-LISP)
  (:shadow AND))

(defpackage I-LISP-COMPILER
  (:use COMMON-LISP)
  (:export *FINISH-CALL-N-OPCODE*))

(in-package "ALPHA-AXP-INTERNALS")

(defmacro lc (str)
  `(if (numberp ,str)
     ,str
    (string-downcase ,str)))

(defmacro defsubst (name arglist &body body)
   `(progn
      (declaim (inline ,name))
      (defun ,name ,arglist ,@body)))

(defmacro stack-let (vars-and-vals &body body)
   (let ((vars (loop for var-and-val in vars-and-vals
 		    if (atom var-and-val)
  		      collect var-and-val
 		    else
 		      collect (first var-and-val))))
     `(let ,vars-and-vals
        (declare (dynamic-extent ,@vars))
        ,@body)))

(defun circular-list (&rest list)
  (let ((list (copy-list list)))
    (setf (cdr (last list)) list)
    list))

(defmacro define-integer-register (name reg &rest other))

(defun register-asmname (name)
;  (format t "register-asmname: ~S~%" name)
  (lc name))

(defun find-register (name)
;  (format t "find-register: ~S~%" name)
  (lc name))

(in-package "SYSTEM")

(defun %logdpb (value bytespec integer)
  (let ((result (dpb value bytespec integer)))
     (if (zerop (ldb (byte 1 31) result))
	 result
       (- (ldb (byte 31 0) (1+ (lognot result)))))))

;;
(in-package "ALPHA-AXP-INTERNALS")

;; The function alignment is 3 so that calling into a new procedure
;; causes all a large number of the instructions following the initial
;; instruction to be read into the cache.
(defparameter *function-alignment* 5)

(defun coerce-to-register (reg)
  reg)

(defun coerce-to-register-or-literal (reglit)
  reglit)

(defun lsh (num places)
  (if (>= num 0) (ash num places)
    (if (>= places 0) (ash num places)
      (ash
       (logior
	(ash (logand -1 most-positive-fixnum) -1)
	(ash (+ most-positive-fixnum 1) -2)) (+ 1 places)))))

;;

(defun c-header (destination sourcename)
  (format destination
	  "~&/************************************************************************")
  (format destination
	  "~& * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED")
  (format destination
	  "~& * FROM ~a. ANY CHANGES MADE TO THIS FILE WILL BE LOST" sourcename)
  (format destination
	  "~& ************************************************************************/~%~%"))

(defun c-trailer (destination sourcename)
  (format destination
	  "~%~%~%/* End of file automatically generated from ~a */~%" sourcename))

(defvar *function-being-processed* nil)
(defvar *function-epilogue*)

;
(defun macroexpand-careful (form env)
;  (format t "xxx: ~S~%" (car form))
  (if (eq (car form) 'AND)
      form
    (macroexpand form env)))

(defun macroexpand-asm-form (form &optional env)
  (if (consp (first form))
      (loop for meform in form
	    as expanded = (macroexpand-asm-form meform env)
	    if (consp (first expanded))
	      append expanded
	    else
	      collect expanded)
      (let ((expanded (macroexpand-careful form env)))
	(if (eq expanded form)
(progn
;(format t "macroexpand-asm-form: form ~S~%" form)
	    form
)
	    (macroexpand-asm-form expanded env)))))

(defun collecting-function-epilogue (body env)
  (let ((*function-epilogue* nil))
    `(,@(mapcar #'(lambda (x) (macroexpand-asm-form x env)) body)
      ,@(loop while *function-epilogue*
	      append (mapcar #'(lambda (x) (macroexpand-asm-form x env))
			     (shiftf *function-epilogue* nil))))))

(defmacro define-procedure (name (&rest args) &body body &environment env)
  (let ((*function-being-processed* name))
    `((start ,name ,(length args))
;      (label ,name)
      (func-label ,name)
      ,@(collecting-function-epilogue body env)
      (end ,name))))

(defmacro check-comment (arg)
  `(if ,arg (format destination "  /* ~A */~%" ,arg)))

(defun remap-arg (str)
  (cdr (assoc str
	'((ICP . "iCP")
	  (IPC . "iPC")
	  (ISP . "iSP")
	  (IFP . "iFP")
	  (ILP . "iLP")
	  (ILP . "iLP")
	  (CACHELINE_NEXTPCDATA . "nextpcdata")
	  (CACHELINE_NEXTCP . "nextcp")
	  (CACHELINE_PCDATA . "pcdata")
	  (CACHELINE_INSTRUCTION . "instruction")
	  (CACHELINE_ANNOTATION . "annotation")
	  (CACHELINE_CODE . "code")
	  (CACHELINE_OPERAND . "operand")
	  (CACHELINESIZE . "CACHELINE_SIZE") ;

	  ;;--
	  (PROCESSORSTATE_TRANSPARE3 . "transpare3")
	  (PROCESSORSTATE_TRANSPARE2 . "transpare2")
	  (PROCESSORSTATE_TRANSPARE1 . "transpare1")
	  (PROCESSORSTATE_CARCDRSUBROUTINE . "carcdrsubroutine")
	  (PROCESSORSTATE_CDRSUBROUTINE . "cdrsubroutine")
	  (PROCESSORSTATE_CARSUBROUTINE . "carsubroutine")
	  (PROCESSORSTATE_LINKAGE . "linkage")
	  (PROCESSORSTATE_RESUMEEMA . "resumeema")
	  (PROCESSORSTATE_STATISTICS . "statistics")
	  (PROCESSORSTATE_TRACE_HOOK . "trace_hook")
	  (PROCESSORSTATE_INSTRUCTION_COUNT . "instruction_count")
	  (PROCESSORSTATE_LONG_PAD0 . "long_pad0")
	  (PROCESSORSTATE_ASRR9 . "asrr9")
	  (PROCESSORSTATE_ASRR10 . "asrr10")
	  (PROCESSORSTATE_ASRR11 . "asrr11")
	  (PROCESSORSTATE_ASRR12 . "asrr12")
	  (PROCESSORSTATE_ASRR13 . "asrr13")
	  (PROCESSORSTATE_ASRR14 . "asrr14")
	  (PROCESSORSTATE_ASRR15 . "asrr15")
	  (PROCESSORSTATE_LONG_PAD1 . "long_pad1")
	  (PROCESSORSTATE_ASRR26 . "asrr26")
	  (PROCESSORSTATE_ASRR27 . "asrr27")
	  (PROCESSORSTATE_ASRR29 . "asrr29")
	  (PROCESSORSTATE_ASRR30 . "asrr30")
	  (PROCESSORSTATE_ASRF2 . "asrf2")
	  (PROCESSORSTATE_ASRF3 . "asrf3")
	  (PROCESSORSTATE_ASRF4 . "asrf4")
	  (PROCESSORSTATE_ASRF5 . "asrf5")
	  (PROCESSORSTATE_ASRF6 . "asrf6")
	  (PROCESSORSTATE_ASRF7 . "asrf7")
	  (PROCESSORSTATE_ASRF8 . "asrf8")
	  (PROCESSORSTATE_ASRF9 . "asrf9")
	  (PROCESSORSTATE_METERDATABUFF . "meterdatabuff")
	  (PROCESSORSTATE_METERPOS . "meterpos")
	  (PROCESSORSTATE_METERMAX . "metermax")
	  (PROCESSORSTATE_METERFREQ . "meterfreq")
	  (PROCESSORSTATE_METERMASK . "metermask")
	  (PROCESSORSTATE_METERVALUE . "metervalue")
	  (PROCESSORSTATE_METERCOUNT . "metercount")
	  (PROCESSORSTATE_CHOICEPTR . "choiceptr")
	  (PROCESSORSTATE_SSTKCHOICEPTR . "sstkchoiceptr")
	  (PROCESSORSTATE_DBCBASE . "dbcbase")
	  (PROCESSORSTATE_DBCMASK . "dbcmask")
	  (PROCESSORSTATE_COPROCESSORREADHOOK . "coprocessorreadhook")
	  (PROCESSORSTATE_COPROCESSORWRITEHOOK . "coprocessorwritehook")
	  (PROCESSORSTATE_FLUSHCACHES_HOOK . "flushcaches_hook")
	  (PROCESSORSTATE_I_STAGE_ERROR_HOOK . "i_stage_error_hook")
	  (PROCESSORSTATE_SFP1 . "sfp1")
	  (PROCESSORSTATE_FP0 . "fp0")
	  (PROCESSORSTATE_FP1 . "fp1")
	  (PROCESSORSTATE_FLOATING_EXCEPTION . "floating_exception")
	  (PROCESSORSTATE_ALUANDROTATECONTROL . "aluandrotatecontrol")
	  (PROCESSORSTATE_ROTATELATCH . "rotatelatch")
	  (PROCESSORSTATE_ALUBORROW . "aluborrow")
	  (PROCESSORSTATE_ALUOVERFLOW . "aluoverflow")
	  (PROCESSORSTATE_ALULESSTHAN . "alulessthan")
	  (PROCESSORSTATE_ALUOP . "aluop")
	  (PROCESSORSTATE_BYTEROTATE . "byterotate")
	  (PROCESSORSTATE_BYTESIZE . "bytesize")
	  (PROCESSORSTATE_BINDINGSTACKLIMIT . "bindingstacklimit")
	  (PROCESSORSTATE_BINDINGSTACKPOINTER . "bindingstackpointer")
	  (PROCESSORSTATE_CATCHBLOCK . "catchblock")
	  (PROCESSORSTATE_EXTRAANDCATCH . "extraandcatch")
	  (PROCESSORSTATE_MSCLOCKCACHE . "msclockcache")
	  (PROCESSORSTATE_MSCMULTIPLIER . "mscmultiplier")
	  (PROCESSORSTATE_PREVIOUSRCPP . "previousrcpp")
	  (PROCESSORSTATE_RLINK . "rlink")
	  (PROCESSORSTATE_INTERRUPTREG . "interruptreg")
	  (PROCESSORSTATE_ZONEOLDSPACE . "zoneoldspace")
	  (PROCESSORSTATE_EPHEMERALOLDSPACE . "ephemeraloldspace")
	  (PROCESSORSTATE_INT_PAD0 . "int_pad0")
	  (PROCESSORSTATE_EQNOTEQL . "eqnoteql")
	  (PROCESSORSTATE_LCLENGTH . "lclength")
	  (PROCESSORSTATE_SCLENGTH . "sclength")
	  (PROCESSORSTATE_LCAREA . "lcarea")
	  (PROCESSORSTATE_LCADDRESS . "lcaddress")
	  (PROCESSORSTATE_SCAREA . "scarea")
	  (PROCESSORSTATE_SCADDRESS . "scaddress")
	  (PROCESSORSTATE_RESTARTSP . "restartsp")
	  (PROCESSORSTATE_STOP_INTERPRETER . "stop_interpreter")
	  (PROCESSORSTATE_IMMEDIATE_ARG . "immediate_arg")
	  (PROCESSORSTATE_CONTINUATIONCP . "continuationcp")
	  (PROCESSORSTATE_CONTINUATION . "continuation")
	  (PROCESSORSTATE_CONTROL . "control")
	  (PROCESSORSTATE_NILADDRESS . "niladdress")
	  (PROCESSORSTATE_TADDRESS . "taddress")
	  (PROCESSORSTATE_BAR0 . "bar0")
	  (PROCESSORSTATE_BAR1 . "bar1")
	  (PROCESSORSTATE_BAR2 . "bar2")
	  (PROCESSORSTATE_BAR3 . "bar3")
	  (PROCESSORSTATE_EPC . "epc")
	  (PROCESSORSTATE_FP . "fp")
	  (PROCESSORSTATE_LP . "lp")
	  (PROCESSORSTATE_SP . "sp")
	  (PROCESSORSTATE_CP . "cp")
	  (PROCESSORSTATE_FCCRMASK . "fccrmask")
	  (PROCESSORSTATE_CSLIMIT . "cslimit")
	  (PROCESSORSTATE_CSEXTRALIMIT . "csextralimit")
	  (PROCESSORSTATE_TRAPMETERDATA . "trapmeterdata")
	  (PROCESSORSTATE_FEPMODETRAPVECADDRESS . "fepmodetrapvecaddress")
	  (PROCESSORSTATE_TRAPVECBASE . "trapvecbase")
	  (PROCESSORSTATE_TVI . "tvi")
	  (PROCESSORSTATE_FCCRTRAPMASK . "fccrtrapmask")
	  (PROCESSORSTATE_PTRTYPE . "ptrtype")
	  (PROCESSORSTATE_VMATTRIBUTETABLE . "vmattributetable")
	  (PROCESSORSTATE_VMA . "vma")
	  (PROCESSORSTATE_MOSTNEGATIVEFIXNUM . "mostnegativefixnum")
	  (PROCESSORSTATE_ICACHEBASE . "icachebase")
	  (PROCESSORSTATE_ENDICACHE . "endicache")
	  (PROCESSORSTATE_FULLWORDDISPATCH . "fullworddispatch")
	  (PROCESSORSTATE_HALFWORDDISPATCH . "halfworddispatch")
	  (PROCESSORSTATE_AREVENTCOUNT . "areventcount")
	  (PROCESSORSTATE_STACKCACHESIZE . "stackcachesize")
	  (PROCESSORSTATE_STACKCACHETOPVMA . "stackcachetopvma")
	  (PROCESSORSTATE_CDRCODEMASK . "cdrcodemask")
	  (PROCESSORSTATE_STACKCACHEDATA . "stackcachedata")
	  (PROCESSORSTATE_STACKCACHEBASEVMA . "stackcachebasevma")
	  (PROCESSORSTATE_SCOVLIMIT . "scovlimit")
	  (PROCESSORSTATE_SCOVDUMPCOUNT . "scovdumpcount")
	  (PROCESSORSTATE_MOSTPOSITIVEFIXNUM . "mostpositivefixnum")
	  (PROCESSORSTATE_INTERNALREGISTERREAD1 . "internalregisterread1")
	  (PROCESSORSTATE_INTERNALREGISTERREAD2 . "internalregisterread2")
	  (PROCESSORSTATE_INTERNALREGISTERWRITE1 . "internalregisterwrite1")
	  (PROCESSORSTATE_INTERNALREGISTERWRITE2 . "internalregisterwrite2")
	  (PROCESSORSTATE_DATAREAD_MASK . "dataread_mask")
	  (PROCESSORSTATE_DATAREAD . "dataread")
	  (PROCESSORSTATE_DATAWRITE_MASK . "datawrite_mask")
	  (PROCESSORSTATE_DATAWRITE . "datawrite")
	  (PROCESSORSTATE_BINDREAD_MASK . "bindread_mask")
	  (PROCESSORSTATE_BINDREAD . "bindread")
	  (PROCESSORSTATE_BINDWRITE_MASK . "bindwrite_mask")
	  (PROCESSORSTATE_BINDWRITE . "bindwrite")
	  (PROCESSORSTATE_BINDREADNOMONITOR_MASK . "bindreadnomonitor_mask")
	  (PROCESSORSTATE_BINDREADNOMONITOR . "bindreadnomonitor")
	  (PROCESSORSTATE_BINDWRITENOMONITOR_MASK . "bindwritenomonitor_mask")
	  (PROCESSORSTATE_BINDWRITENOMONITOR . "bindwritenomonitor")
	  (PROCESSORSTATE_HEADER_MASK . "header_mask")
	  (PROCESSORSTATE_HEADER . "header")
	  (PROCESSORSTATE_STRUCTUREOFFSET_MASK . "structureoffset_mask")
	  (PROCESSORSTATE_STRUCTUREOFFSET . "structureoffset")
	  (PROCESSORSTATE_SCAVENGE_MASK . "scavenge_mask")
	  (PROCESSORSTATE_SCAVENGE . "scavenge")
	  (PROCESSORSTATE_CDR_MASK . "cdr_mask")
	  (PROCESSORSTATE_CDR . "cdr")
	  (PROCESSORSTATE_GCCOPY_MASK . "gccopy_mask")
	  (PROCESSORSTATE_GCCOPY . "gccopy")
	  (PROCESSORSTATE_RAW_MASK . "raw_mask")
	  (PROCESSORSTATE_RAW . "raw")
	  (PROCESSORSTATE_RAWTRANSLATE_MASK . "rawtranslate_mask")
	  (PROCESSORSTATE_RAWTRANSLATE . "rawtranslate")
	  (PROCESSORSTATE_PLEASE_STOP . "please_stop")
	  (PROCESSORSTATE_PLEASE_TRAP . "please_trap")
	  (PROCESSORSTATE_RUNNINGP . "runningp")
	  (PROCESSORSTATE_AC0ARRAY . "ac0array")
	  (PROCESSORSTATE_AC0ARWORD . "ac0arword")
	  (PROCESSORSTATE_AC0LOCAT . "ac0locat")
	  (PROCESSORSTATE_AC0LENGTH . "ac0length")
	  (PROCESSORSTATE_AC1ARRAY . "ac1array")
	  (PROCESSORSTATE_AC1ARWORD . "ac1arword")
	  (PROCESSORSTATE_AC1LOCAT . "ac1locat")
	  (PROCESSORSTATE_AC1LENGTH . "ac1length")
	  (PROCESSORSTATE_AC2ARRAY . "ac2array")
	  (PROCESSORSTATE_AC2ARWORD . "ac2arword")
	  (PROCESSORSTATE_AC2LOCAT . "ac2locat")
	  (PROCESSORSTATE_AC2LENGTH . "ac2length")
	  (PROCESSORSTATE_AC3ARRAY . "ac3array")
	  (PROCESSORSTATE_AC3ARWORD . "ac3arword")
	  (PROCESSORSTATE_AC3LOCAT . "ac3locat")
	  (PROCESSORSTATE_AC3LENGTH . "ac3length")
	  (PROCESSORSTATE_AC4ARRAY . "ac4array")
	  (PROCESSORSTATE_AC4ARWORD . "ac4arword")
	  (PROCESSORSTATE_AC4LOCAT . "ac4locat")
	  (PROCESSORSTATE_AC4LENGTH . "ac4length")
	  (PROCESSORSTATE_AC5ARRAY . "ac5array")
	  (PROCESSORSTATE_AC5ARWORD . "ac5arword")
	  (PROCESSORSTATE_AC5LOCAT . "ac5locat")
	  (PROCESSORSTATE_AC5LENGTH . "ac5length")
	  (PROCESSORSTATE_AC6ARRAY . "ac6array")
	  (PROCESSORSTATE_AC6ARWORD . "ac6arword")
	  (PROCESSORSTATE_AC6LOCAT . "ac6locat")
	  (PROCESSORSTATE_AC6LENGTH . "ac6length")
	  (PROCESSORSTATE_AC7ARRAY . "ac7array")
	  (PROCESSORSTATE_AC7ARWORD . "ac7arword")
	  (PROCESSORSTATE_AC7LOCAT . "ac7locat")
	  (PROCESSORSTATE_AC7LENGTH . "ac7length")
	  (PROCESSORSTATE_TMCURRENTTRANSACTION . "tmcurrenttransaction")
	  (PROCESSORSTATE_TMWRITESTART . "tmwritestart")
	  (PROCESSORSTATE_TMWRITECURRENT . "tmwritecurrent")
	  (PROCESSORSTATE_TMWRITELIMIT . "tmwritelimit")
	  (PROCESSORSTATE_TMRECORDINGREADS . "tmrecordingreads")
	  (PROCESSORSTATE_TMREADSTART . "tmreadstart")
	  (PROCESSORSTATE_TMREADCURRENT . "tmreadcurrent")
	  (PROCESSORSTATE_TMREADLIMIT . "tmreadlimit")
	  ;;--

	  (arraycache_array . "array")
	  (arraycache_arword . "arword")
	  (arraycache_locat . "locat")
	  (arraycache_length . "length")

	  (CACHELINERSHIFT . "CacheLine_RShift")
	  (CACHELINELSHIFT . "CacheLine_LShift")

	  (|CacheLineRShift| . "CacheLine_RShift")
	  (|CacheLineLShift| . "CacheLine_LShift")

	  ("CacheLineRShift" . "CacheLine_RShift")
	  ("CacheLineLShift" . "CacheLine_LShift")

	  (|MemoryActionIndirect| . "MemoryActionIndirect")
	  (|MemoryActionMonitor| . "MemoryActionMonitor")
	  (|MemoryActionTransport| . "MemoryActionTransport")
	  (|MemoryActionTrap| . "MemoryActionTrap")
	  (|MemoryActionTransform| . "MemoryActionTransform")
	  (|MemoryActionBinding| . "MemoryActionBinding")

	  (|MemoryPageSize| . "MemoryPage_Size")
	  (|MemoryPageAddressShift| . "MemoryPage_AddressShift")

	  (|VMAttributeAccessFault| . "VMAttribute_AccessFault")
	  (|VMAttributeWriteFault| . "VMAttribute_WriteFault")
	  (|VMAttributeTransportFault| . "VMAttribute_TransportFault")
	  (|VMAttributeTransportDisable| . "VMAttribute_TransportDisable")
	  (|VMAttributeEphemeral| . "VMAttribute_Ephemeral")
	  (|VMAttributeModified| . "VMAttribute_Modified")
	  (|VMAttributeExists| . "VMAttribute_Exists")
	  (|VMAttributeCreatedDefault| . "VMAttribute_CreatedDefault")


	  (twocachelinesize . "TWOCACHELINESIZE")
	  (fourcachelinesize . "FOURCACHELINESIZE")

	  ;;--
	  (|TypeNull| . "Type_Null")
	  (|TypeMonitorForward| . "Type_MonitorForward")
	  (|TypeHeaderP| . "Type_HeaderP")
	  (|TypeHeaderI| . "Type_HeaderI")
	  (|TypeExternalValueCellPointer| . "Type_ExternalValueCellPointer")
	  (|TypeOneQForward| . "Type_OneQForward")
	  (|TypeHeaderForward| . "Type_HeaderForward")
	  (|TypeElementForward| . "Type_ElementForward")
	  (|TypeFixnum| . "Type_Fixnum")
	  (|TypeSmallRatio| . "Type_SmallRatio")
	  (|TypeSingleFloat| . "Type_SingleFloat")
	  (|TypeDoubleFloat| . "Type_DoubleFloat")
	  (|TypeBignum| . "Type_Bignum")
	  (|TypeBigRatio| . "Type_BigRatio")
	  (|TypeComplex| . "Type_Complex")
	  (|TypeSpareNumber| . "Type_SpareNumber")
	  (|TypeInstance| . "Type_Instance")
	  (|TypeListInstance| . "Type_ListInstance")
	  (|TypeArrayInstance| . "Type_ArrayInstance")
	  (|TypeStringInstance| . "Type_StringInstance")
	  (|TypeNIL| . "Type_NIL")
	  (|TypeList| . "Type_List")
	  (|TypeArray| . "Type_Array")
	  (|TypeString| . "Type_String")
	  (|TypeSymbol| . "Type_Symbol")
	  (|TypeLocative| . "Type_Locative")
	  (|TypeLexicalClosure| . "Type_LexicalClosure")
	  (|TypeDynamicClosure| . "Type_DynamicClosure")
	  (|TypeCompiledFunction| . "Type_CompiledFunction")
	  (|TypeGenericFunction| . "Type_GenericFunction")
	  (|TypeSparePointer1| . "Type_SparePointer1")
	  (|TypeSparePointer2| . "Type_SparePointer2")
	  (|TypePhysicalAddress| . "Type_PhysicalAddress")
	  (|TypeNativeInstruction| . "Type_NativeInstruction")
	  (|TypeBoundLocation| . "Type_BoundLocation")
	  (|TypeCharacter| . "Type_Character")
	  (|TypeLogicVariable| . "Type_LogicVariable")
	  (|TypeGCForward| . "Type_GCForward")
	  (|TypeEvenPC| . "Type_EvenPC")
	  (|TypeOddPC| . "Type_OddPC")
	  (|TypeCallCompiledEven| . "Type_CallCompiledEven")
	  (|TypeCallCompiledOdd| . "Type_CallCompiledOdd")
	  (|TypeCallIndirect| . "Type_CallIndirect")
	  (|TypeCallGeneric| . "Type_CallGeneric")
	  (|TypeCallCompiledEvenPrefetch| . "Type_CallCompiledEvenPrefetch")
	  (|TypeCallCompiledOddPrefetch| . "Type_CallCompiledOddPrefetch")
	  (|TypeCallIndirectPrefetch| . "Type_CallIndirectPrefetch")
	  (|TypeCallGenericPrefetch| . "Type_CallGenericPrefetch")
	  (|TypePackedInstruction60| . "Type_PackedInstruction60")
	  (|TypeTypePackedInstruction61| . "Type_TypePackedInstruction61")
	  (|TypeTypePackedInstruction62| . "Type_TypePackedInstruction62")
	  (|TypePackedInstruction63| . "Type_PackedInstruction63")
	  (|TypeTypePackedInstruction64| . "Type_TypePackedInstruction64")
	  (|TypeTypePackedInstruction65| . "Type_TypePackedInstruction65")
	  (|TypePackedInstruction66| . "Type_PackedInstruction66")
	  (|TypeTypePackedInstruction67| . "Type_TypePackedInstruction67")
	  (|TypeTypePackedInstruction70| . "Type_TypePackedInstruction70")
	  (|TypePackedInstruction71| . "Type_PackedInstruction71")
	  (|TypeTypePackedInstruction72| . "Type_TypePackedInstruction72")
	  (|TypeTypePackedInstruction73| . "Type_TypePackedInstruction73")
	  (|TypePackedInstruction74| . "Type_PackedInstruction74")
	  (|TypeTypePackedInstruction75| . "Type_TypePackedInstruction75")
	  (|TypeTypePackedInstruction76| . "Type_TypePackedInstruction76")
	  (|TypePackedInstruction77| . "Type_PackedInstruction77")
	  ;;--

	  (|ArrayElementTypeFixnum| . "Array_ElementTypeFixnum")
	  (|ArrayElementTypeCharacter| . "Array_ElementTypeCharacter")
	  (|ArrayElementTypeBoolean| . "Array_ElementTypeBoolean")
	  (|ArrayElementTypeObject| . "Array_ElementTypeObject")
	  (|ArrayTypeFieldPos| . "Array_TypeFieldPos")
	  (|ArrayTypeFieldSize| . "Array_TypeFieldSize")
	  (|ArrayTypeFieldMask| . "Array_TypeFieldMask")
	  (|ArrayElementTypePos| . "Array_ElementTypePos")
	  (|ArrayElementTypeSize| . "Array_ElementTypeSize")
	  (|ArrayElementTypeMask| . "Array_ElementTypeMask")
	  (|ArrayBytePackingPos| . "Array_BytePackingPos")
	  (|ArrayBytePackingSize| . "Array_BytePackingSize")
	  (|ArrayBytePackingMask| . "Array_BytePackingMask")
	  (|ArrayListBitPos| . "Array_ListBitPos")
	  (|ArrayListBitSize| . "Array_ListBitSize")
	  (|ArrayListBitMask| . "Array_ListBitMask")
	  (|ArrayNamedStructureBitPos| . "Array_NamedStructureBitPos")
	  (|ArrayNamedStructureBitSize| . "Array_NamedStructureBitSize")
	  (|ArrayNamedStructureBitMask| . "Array_NamedStructureBitMask")
	  (|ArraySpare1Pos| . "Array_Spare1Pos")
	  (|ArraySpare1Size| . "Array_Spare1Size")
	  (|ArraySpare1Mask| . "Array_Spare1Mask")
	  (|ArrayLongPrefixBitPos| . "Array_LongPrefixBitPos")
	  (|ArrayLongPrefixBitSize| . "Array_LongPrefixBitSize")
	  (|ArrayLongPrefixBitMask| . "Array_LongPrefixBitMask")
	  (|ArrayLeaderLengthFieldPos| . "Array_LeaderLengthFieldPos")
	  (|ArrayLeaderLengthFieldSize| . "Array_LeaderLengthFieldSize")
	  (|ArrayLeaderLengthFieldMask| . "Array_LeaderLengthFieldMask")
	  (|ArrayLengthPos| . "Array_LengthPos")
	  (|ArrayLengthSize| . "Array_LengthSize")
	  (|ArrayLengthMask| . "Array_LengthMask")
	  (|ArrayDisplacedBitPos| . "Array_DisplacedBitPos")
	  (|ArrayDisplacedBitSize| . "Array_DisplacedBitSize")
	  (|ArrayDisplacedBitMask| . "Array_DisplacedBitMask")
	  (|ArrayDiscontiguousBitPos| . "Array_DiscontiguousBitPos")
	  (|ArrayDiscontinuousBitSize| . "Array_DiscontinuousBitSize")
	  (|ArrayDiscontiguousBitMask| . "Array_DiscontiguousBitMask")
	  (|ArrayLongSparePos| . "Array_LongSparePos")
	  (|ArrayLongSpareSize| . "Array_LongSpareSize")
	  (|ArrayLongSpareMask| . "Array_LongSpareMask")
	  (|ArrayLongDimensionsFieldPos| . "Array_LongDimensionsFieldPos")
	  (|ArrayLongDimensionsFieldSize| . "Array_LongDimensionsFieldSize")
	  (|ArrayLongDimensionsFieldMask| . "Array_LongDimensionsFieldMask")
	  (|ArrayRegisterElementTypePos| . "Array_RegisterElementTypePos")
	  (|ArrayRegisterElementTypeSize| . "Array_RegisterElementTypeSize")
	  (|ArrayRegisterElementTypeMask| . "Array_RegisterElementTypeMask")
	  (|ArrayRegisterBytePackingPos| . "Array_RegisterBytePackingPos")
	  (|ArrayRegisterBytePackingSize| . "Array_RegisterBytePackingSize")
	  (|ArrayRegisterBytePackingMask| . "Array_RegisterBytePackingMask")
	  (|ArrayRegisterByteOffsetPos| . "Array_RegisterByteOffsetPos")
	  (|ArrayRegisterByteOffsetSize| . "Array_RegisterByteOffsetSize")
	  (|ArrayRegisterByteOffsetMask| . "Array_RegisterByteOffsetMask")
	  (|ArrayRegisterEventCountPos| . "Array_RegisterEventCountPos")
	  (|ArrayRegisterEventCountSize| . "Array_RegisterEventCountSize")
	  (|ArrayRegisterEventCountMask| . "Array_RegisterEventCountMask")

	  (|AutoArrayRegMask| . "AutoArrayRegMask")
	  (|AutoArrayRegSize| . "AutoArrayRegSize")
	  (|AutoArrayRegShift| . "AutoArrayRegShift")

	  (|CdrNext| . "Cdr_Next")
	  (|CdrNil| . "Cdr_Nil")
	  (|CdrNormal| . "Cdr_Normal")

	  (|ReturnValueNormal| . "ReturnValue_Normal")
	  (|ReturnValueException| . "ReturnValue_Exception")
	  (|ReturnValueIllegalOperand| . "ReturnValue_IllegalOperand")

	  (|ALUFunctionBoolean| . "ALUFunction_Boolean")
	  (|ALUFunctionByte| . "ALUFunction_Byte")
	  (|ALUFunctionAdder| . "ALUFunction_Adder")
	  (|ALUFunctionMultiplyDivide| . "ALUFunction_MultiplyDivide")

	  (|ALUConditionSignedLessThanOrEqual| . "ALUCondition_SignedLessThanOrEqual")
	  (|ALUConditionSignedLessThan| . "ALUCondition_SignedLessThan")
	  (|ALUConditionNegative| . "ALUCondition_Negative")
	  (|ALUConditionSignedOverflow| . "ALUCondition_SignedOverflow")
	  (|ALUConditionUnsignedLessThanOrEqual| . "ALUCondition_UnsignedLessThanOrEqual")
	  (|ALUConditionUnsignedLessThan| . "ALUCondition_UnsignedLessThan")
	  (|ALUConditionZero| . "ALUCondition_Zero")
	  (|ALUConditionHigh25Zero| . "ALUCondition_High25Zero")
	  (|ALUConditionEq| . "ALUCondition_Eq")
	  (|ALUConditionOp1Ephemeralp| . "ALUCondition_Op1Ephemeralp")
	  (|ALUConditionOp1TypeAcceptable| . "ALUCondition_Op1TypeAcceptable")
	  (|ALUConditionOp1TypeCondition| . "ALUCondition_Op1TypeCondition")
	  (|ALUConditionResultTypeNil| . "ALUCondition_ResultTypeNil")
	  (|ALUConditionOp2Fixnum| . "ALUCondition_Op2Fixnum")
	  (|ALUConditionFalse| . "ALUCondition_False")
	  (|ALUConditionResultCdrLow| . "ALUCondition_ResultCdrLow")
	  (|ALUConditionCleanupBitsSet| . "ALUCondition_CleanupBitsSet")
	  (|ALUConditionAddressInStackCache| . "ALUCondition_AddressInStackCache")
	  (|ALUConditionPendingSequenceBreakEnabled| . "ALUCondition_PendingSequenceBreakEnabled")
	  (|ALUConditionExtraStackMode| . "ALUCondition_ExtraStackMode")
	  (|ALUConditionFepMode| . "ALUCondition_FepMode")
	  (|ALUConditionFpCoprocessorPresent| . "ALUCondition_FpCoprocessorPresent")
	  (|ALUConditionOp1Oldspacep| . "ALUCondition_Op1Oldspacep")
	  (|ALUConditionStackCacheOverflow| . "ALUCondition_StackCacheOverflow")
	  (|ALUConditionOrLogicVariable| . "ALUCondition_OrLogicVariable")
	  (|ALUAdderOp2Op2| . "ALUAdderOp2_Op2")
	  (|ALUAdderOp2Zero| . "ALUAdderOp2_Zero")
	  (|ALUAdderOp2Invert| . "ALUAdderOp2_Invert")
	  (|ALUAdderOp2MinusOne| . "ALUAdderOp2_MinusOne")
	  (|ALUByteFunctionDpb| . "ALUByteFunction_Dpb")
	  (|ALUByteFunctionLdb| . "ALUByteFunction_Ldb")
	  (|ALUByteBackgroundOp1| . "ALUByteBackground_Op1")
	  (|ALUByteBackgroundRotateLatch| . "ALUByteBackground_RotateLatch")
	  (|ALUByteBackgroundZero| . "ALUByteBackground_Zero")

	  (|BooleClear| . "Boole_Clear")
	  (|BooleAnd| . "Boole_And")
	  (|BooleAndC1| . "Boole_AndC1")
	  (|Boole2| . "Boole_2")
	  (|BooleAndC2| . "Boole_AndC2")
	  (|Boole1| . "Boole_1")
	  (|BooleXor| . "Boole_Xor")
	  (|BooleIor| . "Boole_Ior")
	  (|BooleNor| . "Boole_Nor")
	  (|BooleEquiv| . "Boole_Equiv")
	  (|BooleC1| . "Boole_C1")
	  (|BooleOrC1| . "Boole_OrC1")
	  (|BooleC2| . "Boole_C2")
	  (|BooleOrC2| . "Boole_OrC2")
	  (|BooleNand| . "Boole_Nand")
	  (|BooleSet| . "Boole_Set")

	  (|CoprocessorRegisterUnwindStackForRestartOrApply| . "CoprocessorRegister_UnwindStackForRestartOrApply")
	  (|CoprocessorRegisterFlushIDCaches| . "CoprocessorRegister_FlushIDCaches")
	  (|CoprocessorRegisterFlushCachesForVMA| . "CoprocessorRegister_FlushCachesForVMA")
	  (|CoprocessorRegisterFlushHiddenArrayRegisters| . "CoprocessorRegister_FlushHiddenArrayRegisters")

	  (|CycleDataRead| . "Cycle_DataRead")
	  (|CycleDataWrite| . "Cycle_DataWrite")
	  (|CycleBindRead| . "Cycle_BindRead")
	  (|CycleBindWrite| . "Cycle_BindWrite")
	  (|CycleBindReadNoMonitor| . "Cycle_BindReadNoMonitor")
	  (|CycleBindWriteNoMonitor| . "Cycle_BindWriteNoMonitor")
	  (|CycleHeader| . "Cycle_Header")
	  (|CycleStructureOffset| . "Cycle_StructureOffset")
	  (|CycleScavenge| . "Cycle_Scavenge")
	  (|CycleCdr| . "Cycle_Cdr")
	  (|CycleGCCopy| . "Cycle_GCCopy")
	  (|CycleRaw| . "Cycle_Raw")
	  (|CycleRawTranslate| . "Cycle_RawTranslate")

	  (|TrapVectorArithmeticInstructionException| . "TrapVector_ArithmeticInstructionException")
	  (|TrapVectorStackOverflow| . "TrapVector_StackOverflow")
	  (|TrapVectorInstructionException| . "TrapVector_InstructionException")
	  (|TrapVectorError| . "TrapVector_Error")
	  (|TrapVectorReset| . "TrapVector_Reset")
	  (|TrapVectorPullApplyArgs| . "TrapVector_PullApplyArgs")
	  (|TrapVectorTrace| . "TrapVector_Trace")
	  (|TrapVectorPreemptRequest| . "TrapVector_PreemptRequest")
	  (|TrapVectorLowPrioritySequenceBreak| . "TrapVector_LowPrioritySequenceBreak")
	  (|TrapVectorHighPrioritySequenceBreak| . "TrapVector_HighPrioritySequenceBreak")
	  (|TrapVectorDBUnwindFrame| . "TrapVector_DBUnwindFrame")
	  (|TrapVectorDBUnwindCatch| . "TrapVector_DBUnwindCatch")
	  (|TrapVectorTransport| . "TrapVector_Transport")
	  (|TrapVectorMonitor| . "TrapVector_Monitor")
	  (|TrapVectorPageNotResident| . "TrapVector_PageNotResident")
	  (|TrapVectorPageFaultRequest| . "TrapVector_PageFaultRequest")
	  (|TrapVectorPageWriteFault| . "TrapVector_PageWriteFault")
	  (|TrapVectorUncorrectableMemoryError| . "TrapVector_UncorrectableMemoryError")
	  (|TrapVectorMemoryBusError| . "TrapVector_MemoryBusError")

	  (|ValueDispositionEffect| . "ValueDisposition_Effect")
	  (|ValueDispositionValue| . "ValueDisposition_Value")
	  (|ValueDispositionReturn| . "ValueDisposition_Return")
	  (|ValueDispositionMultiple| . "ValueDisposition_Multiple")

	  (|TrapReasonHighPrioritySequenceBreak| . "TrapReason_HighPrioritySequenceBreak")
	  (|TrapReasonLowPrioritySequenceBreak| . "TrapReason_LowPrioritySequenceBreak")

	  (|TrapModeEmulator| . "TrapMode_Emulator")
	  (|TrapModeExtraStack| . "TrapMode_ExtraStack")
	  (|TrapModeIO| . "TrapMode_IO")
	  (|TrapModeFEP| . "TrapMode_FEP")

	  (|HaltReasonIllInstn| . "HaltReason_IllInstn")
	  (|HaltReasonHalted| . "HaltReason_Halted")
	  (|HaltReasonSpyCalled| . "HaltReason_SpyCalled")
	  (|HaltReasonFatalStackOverflow| . "HaltReason_FatalStackOverflow")
	  (|HaltReasonIllegalTrapVector| . "HaltReason_IllegalTrapVector")

	  (|DoubleFloatOpAdd| . "DoubleFloatOp_Add")
	  (|DoubleFloatOpSub| . "DoubleFloatOp_Sub")
	  (|DoubleFloatOpMultiply| . "DoubleFloatOp_Multiply")
	  (|DoubleFloatOpDivide| . "DoubleFloatOp_Divide")

	  ))))

;
(defun isconstant (sym)
  (member sym
	  '(|TypeEvenPC|
	    |TrapVectorArithmeticInstructionException|
	    |TrapVectorStackOverflow|
	    |TrapVectorInstructionException|
	    |TrapVectorError|
	    |TrapVectorReset|
	    |TrapVectorPullApplyArgs|
	    |TrapVectorTrace|
	    |TrapVectorPreemptRequest|
	    |TrapVectorLowPrioritySequenceBreak|
	    |TrapVectorHighPrioritySequenceBreak|
	    |TrapVectorDBUnwindFrame|
	    |TrapVectorDBUnwindCatch|
	    |TrapVectorTransport|
	    |TrapVectorMonitor|
	    |TrapVectorPageNotResident|
	    |TrapVectorPageFaultRequest|
	    |TrapVectorPageWriteFault|
	    |TrapVectorUncorrectableMemoryError|
	    |TrapVectorMemoryBusError|
	    |ValueDispositionEffect|
	    |ValueDispositionValue|
	    |ValueDispositionReturn|
	    |ValueDispositionMultiple|
	    )))

;;  (cond
;;   ((eq sym '|TypeEvenPC|) t)
;;   (t nil)))

; return list of strings separated by char
(defun split-by-one-char (string char)
  (loop for i = 0 then (1+ j)
	as j = (position char string :start i)
	collect (subseq string i j)
	while j))

; return list of strings separated by "+"
(defun split-by-one-plus (string)
  (split-by-one-char string #\+))

; return list of strings separated by " "
(defun split-by-one-space (string)
  (split-by-one-char string #\Space))

; return list of strings separated by "*"
(defun split-by-one-star (string)
  (split-by-one-char string #\*))

(defun fixarg (str)
;  (format t "fixarg: str ~S~%" str)
  (let ((sym-name (if (symbolp str) (symbol-name str) nil)))
    (if (search "+" sym-name)
	;; handle case of xxx+4
	(let* ((split-list (split-by-one-plus sym-name))
	       (fixed-arg (fixarg (intern (car split-list))))
	       (last-part (car (cdr split-list))))
	  (setq str (concatenate 'string fixed-arg "+" last-part))
;;	  (format t "fixarg+: a=~S b=~S result ~S~%" fixed-arg last-part str)
	  )
      (if (search "*" sym-name)
	;; handle case of xxx*4
	  (let* ((split-list (split-by-one-star sym-name))
		 (fixed-arg (fixarg (intern (car split-list))))
		 (last-part (car (cdr split-list))))
	    (setq str (concatenate 'string fixed-arg "*" last-part))
;;	  (format t "fixarg+: a=~S b=~S result ~S~%" fixed-arg last-part str)
	    )
	;; normal case
	(let ((new (remap-arg str)))
	  (if new new
	    (if (numberp str) str
	      (string-downcase str))))))))

(defun regnum (arg)
 (subseq arg 1 2))

; return t if string is not a number
(defun notnumber (str)
  (let ((d0 (char-code #\0))
	(d9 (char-code #\9)))
    (some
     #'(lambda (c) (let ((cc (char-code c))) (or (< cc d0) (> cc d9))))
	 str)))

;; return (ptr member offset)
(defun decompose-args (arg1 arg2)
  (let ((arg2-name (if (symbolp arg2) (symbol-name arg2) arg2)))
    (if (not (search "+" arg2-name))
	(values (structptr arg1 arg2) arg2 0)
      ;; handle case of xxx+4
      (let* ((split-list (split-by-one-plus arg2-name))
	     (real-arg2 (intern (car split-list)))
	     (fixed-arg2 (fixarg real-arg2))
	     (offsetlast-part (car (cdr split-list)))
	     (ptr (structptr arg1 real-arg2))
	     (offset (if (notnumber offsetlast-part)
			 offsetlast-part (parse-integer offsetlast-part))))
	(values ptr fixed-arg2 offset)))))


; severe hackery
(defun is-cachep-member (smember)
  (member smember
	  '(cacheline_annotation cacheline_nextpdata cacheline_nextptag
				 cacheline_nextcp cacheline_instruction
				 cacheline_operand cacheline_pcdata
				 cacheline_pctag cacheline_code)))

(defun is-cachep-ptr (str)
  (or (eq str 'ocp) (eq str 'ecp) (eq str 'iCP) (equal str "iCP")))

(defun cacheline-ptr-str (ptr)
  (if (or (eq ptr 'iCP) (equal ptr "iCP")) 
      "iCP"
    (string-downcase ptr)))

(defun needs-cacheline-cast (ptr member)
;  (format t "needs-cacheline-cast: ptr ~S member ~S~%" ptr member)
  (or
   (is-cachep-ptr ptr)
   (is-cachep-member member)))

(defun is-arrachcachep-member (amember)
  (member amember
	  '(arraycache_array
	    arraycache_arword arraycache_locat arraycache_length)))

(defun needs-arraycache-cast (ptr member)
   (is-arrachcachep-member member))

(defun is-processorstatep-member (pmember)
  (member pmember
	  '(
	    ;;--
	    PROCESSORSTATE_TRANSPARE3
	    PROCESSORSTATE_TRANSPARE2
	    PROCESSORSTATE_TRANSPARE1
	    PROCESSORSTATE_CARCDRSUBROUTINE
	    PROCESSORSTATE_CDRSUBROUTINE
	    PROCESSORSTATE_CARSUBROUTINE
	    PROCESSORSTATE_LINKAGE
	    PROCESSORSTATE_RESUMEEMA
	    PROCESSORSTATE_STATISTICS
	    PROCESSORSTATE_TRACE_HOOK
	    PROCESSORSTATE_INSTRUCTION_COUNT
	    PROCESSORSTATE_LONG_PAD0
	    PROCESSORSTATE_ASRR9
	    PROCESSORSTATE_ASRR10
	    PROCESSORSTATE_ASRR11
	    PROCESSORSTATE_ASRR12
	    PROCESSORSTATE_ASRR13
	    PROCESSORSTATE_ASRR14
	    PROCESSORSTATE_ASRR15
	    PROCESSORSTATE_LONG_PAD1
	    PROCESSORSTATE_ASRR26
	    PROCESSORSTATE_ASRR27
	    PROCESSORSTATE_ASRR29
	    PROCESSORSTATE_ASRR30
	    PROCESSORSTATE_ASRF2
	    PROCESSORSTATE_ASRF3
	    PROCESSORSTATE_ASRF4
	    PROCESSORSTATE_ASRF5
	    PROCESSORSTATE_ASRF6
	    PROCESSORSTATE_ASRF7
	    PROCESSORSTATE_ASRF8
	    PROCESSORSTATE_ASRF9
	    PROCESSORSTATE_METERDATABUFF
	    PROCESSORSTATE_METERPOS
	    PROCESSORSTATE_METERMAX
	    PROCESSORSTATE_METERFREQ
	    PROCESSORSTATE_METERMASK
	    PROCESSORSTATE_METERVALUE
	    PROCESSORSTATE_METERCOUNT
	    PROCESSORSTATE_CHOICEPTR
	    PROCESSORSTATE_SSTKCHOICEPTR
	    PROCESSORSTATE_DBCBASE
	    PROCESSORSTATE_DBCMASK
	    PROCESSORSTATE_COPROCESSORREADHOOK
	    PROCESSORSTATE_COPROCESSORWRITEHOOK
	    PROCESSORSTATE_FLUSHCACHES_HOOK
	    PROCESSORSTATE_I_STAGE_ERROR_HOOK
	    PROCESSORSTATE_SFP1
	    PROCESSORSTATE_FP0
	    PROCESSORSTATE_FP1
	    PROCESSORSTATE_FLOATING_EXCEPTION
	    PROCESSORSTATE_ALUANDROTATECONTROL
	    PROCESSORSTATE_ROTATELATCH
	    PROCESSORSTATE_ALUBORROW
	    PROCESSORSTATE_ALUOVERFLOW
	    PROCESSORSTATE_ALULESSTHAN
	    PROCESSORSTATE_ALUOP
	    PROCESSORSTATE_BYTEROTATE
	    PROCESSORSTATE_BYTESIZE
	    PROCESSORSTATE_BINDINGSTACKLIMIT
	    PROCESSORSTATE_BINDINGSTACKPOINTER
	    PROCESSORSTATE_CATCHBLOCK
	    PROCESSORSTATE_EXTRAANDCATCH
	    PROCESSORSTATE_MSCLOCKCACHE
	    PROCESSORSTATE_MSCMULTIPLIER
	    PROCESSORSTATE_PREVIOUSRCPP
	    PROCESSORSTATE_RLINK
	    PROCESSORSTATE_INTERRUPTREG
	    PROCESSORSTATE_ZONEOLDSPACE
	    PROCESSORSTATE_EPHEMERALOLDSPACE
	    PROCESSORSTATE_INT_PAD0
	    PROCESSORSTATE_EQNOTEQL
	    PROCESSORSTATE_LCLENGTH
	    PROCESSORSTATE_SCLENGTH
	    PROCESSORSTATE_LCAREA
	    PROCESSORSTATE_LCADDRESS
	    PROCESSORSTATE_SCAREA
	    PROCESSORSTATE_SCADDRESS
	    PROCESSORSTATE_RESTARTSP
	    PROCESSORSTATE_STOP_INTERPRETER
	    PROCESSORSTATE_IMMEDIATE_ARG
	    PROCESSORSTATE_CONTINUATIONCP
	    PROCESSORSTATE_CONTINUATION
	    PROCESSORSTATE_CONTROL
	    PROCESSORSTATE_NILADDRESS
	    PROCESSORSTATE_TADDRESS
	    PROCESSORSTATE_BAR0
	    PROCESSORSTATE_BAR1
	    PROCESSORSTATE_BAR2
	    PROCESSORSTATE_BAR3
	    PROCESSORSTATE_EPC
	    PROCESSORSTATE_FP
	    PROCESSORSTATE_LP
	    PROCESSORSTATE_SP
	    PROCESSORSTATE_CP
	    PROCESSORSTATE_FCCRMASK
	    PROCESSORSTATE_CSLIMIT
	    PROCESSORSTATE_CSEXTRALIMIT
	    PROCESSORSTATE_TRAPMETERDATA
	    PROCESSORSTATE_FEPMODETRAPVECADDRESS
	    PROCESSORSTATE_TRAPVECBASE
	    PROCESSORSTATE_TVI
	    PROCESSORSTATE_FCCRTRAPMASK
	    PROCESSORSTATE_PTRTYPE
	    PROCESSORSTATE_VMATTRIBUTETABLE
	    PROCESSORSTATE_VMA
	    PROCESSORSTATE_MOSTNEGATIVEFIXNUM
	    PROCESSORSTATE_ICACHEBASE
	    PROCESSORSTATE_ENDICACHE
	    PROCESSORSTATE_FULLWORDDISPATCH
	    PROCESSORSTATE_HALFWORDDISPATCH
	    PROCESSORSTATE_AREVENTCOUNT
	    PROCESSORSTATE_STACKCACHESIZE
	    PROCESSORSTATE_STACKCACHETOPVMA
	    PROCESSORSTATE_CDRCODEMASK
	    PROCESSORSTATE_STACKCACHEDATA
	    PROCESSORSTATE_STACKCACHEBASEVMA
	    PROCESSORSTATE_SCOVLIMIT
	    PROCESSORSTATE_SCOVDUMPCOUNT
	    PROCESSORSTATE_MOSTPOSITIVEFIXNUM
	    PROCESSORSTATE_INTERNALREGISTERREAD1
	    PROCESSORSTATE_INTERNALREGISTERREAD2
	    PROCESSORSTATE_INTERNALREGISTERWRITE1
	    PROCESSORSTATE_INTERNALREGISTERWRITE2
	    PROCESSORSTATE_DATAREAD_MASK
	    PROCESSORSTATE_DATAREAD
	    PROCESSORSTATE_DATAWRITE_MASK
	    PROCESSORSTATE_DATAWRITE
	    PROCESSORSTATE_BINDREAD_MASK
	    PROCESSORSTATE_BINDREAD
	    PROCESSORSTATE_BINDWRITE_MASK
	    PROCESSORSTATE_BINDWRITE
	    PROCESSORSTATE_BINDREADNOMONITOR_MASK
	    PROCESSORSTATE_BINDREADNOMONITOR
	    PROCESSORSTATE_BINDWRITENOMONITOR_MASK
	    PROCESSORSTATE_BINDWRITENOMONITOR
	    PROCESSORSTATE_HEADER_MASK
	    PROCESSORSTATE_HEADER
	    PROCESSORSTATE_STRUCTUREOFFSET_MASK
	    PROCESSORSTATE_STRUCTUREOFFSET
	    PROCESSORSTATE_SCAVENGE_MASK
	    PROCESSORSTATE_SCAVENGE
	    PROCESSORSTATE_CDR_MASK
	    PROCESSORSTATE_CDR
	    PROCESSORSTATE_GCCOPY_MASK
	    PROCESSORSTATE_GCCOPY
	    PROCESSORSTATE_RAW_MASK
	    PROCESSORSTATE_RAW
	    PROCESSORSTATE_RAWTRANSLATE_MASK
	    PROCESSORSTATE_RAWTRANSLATE
	    PROCESSORSTATE_PLEASE_STOP
	    PROCESSORSTATE_PLEASE_TRAP
	    PROCESSORSTATE_RUNNINGP
	    PROCESSORSTATE_AC0ARRAY
	    PROCESSORSTATE_AC0ARWORD
	    PROCESSORSTATE_AC0LOCAT
	    PROCESSORSTATE_AC0LENGTH
	    PROCESSORSTATE_AC1ARRAY
	    PROCESSORSTATE_AC1ARWORD
	    PROCESSORSTATE_AC1LOCAT
	    PROCESSORSTATE_AC1LENGTH
	    PROCESSORSTATE_AC2ARRAY
	    PROCESSORSTATE_AC2ARWORD
	    PROCESSORSTATE_AC2LOCAT
	    PROCESSORSTATE_AC2LENGTH
	    PROCESSORSTATE_AC3ARRAY
	    PROCESSORSTATE_AC3ARWORD
	    PROCESSORSTATE_AC3LOCAT
	    PROCESSORSTATE_AC3LENGTH
	    PROCESSORSTATE_AC4ARRAY
	    PROCESSORSTATE_AC4ARWORD
	    PROCESSORSTATE_AC4LOCAT
	    PROCESSORSTATE_AC4LENGTH
	    PROCESSORSTATE_AC5ARRAY
	    PROCESSORSTATE_AC5ARWORD
	    PROCESSORSTATE_AC5LOCAT
	    PROCESSORSTATE_AC5LENGTH
	    PROCESSORSTATE_AC6ARRAY
	    PROCESSORSTATE_AC6ARWORD
	    PROCESSORSTATE_AC6LOCAT
	    PROCESSORSTATE_AC6LENGTH
	    PROCESSORSTATE_AC7ARRAY
	    PROCESSORSTATE_AC7ARWORD
	    PROCESSORSTATE_AC7LOCAT
	    PROCESSORSTATE_AC7LENGTH
	    PROCESSORSTATE_TMCURRENTTRANSACTION
	    PROCESSORSTATE_TMWRITESTART
	    PROCESSORSTATE_TMWRITECURRENT
	    PROCESSORSTATE_TMWRITELIMIT
	    PROCESSORSTATE_TMRECORDINGREADS
	    PROCESSORSTATE_TMREADSTART
	    PROCESSORSTATE_TMREADCURRENT
	    PROCESSORSTATE_TMREADLIMIT
	    ;;--
	    )))

(defun needs-processorstate-cast (ptr member)
   (is-processorstatep-member member))

(defun check-needs-cast (ptr member)
  (cond
   ((needs-cacheline-cast ptr member)
    (format nil "((CACHELINEP)~A)" (cacheline-ptr-str ptr)))
   ((needs-arraycache-cast ptr member)
    (format nil "((ARRAYCACHEP)~A)" (string-downcase ptr)))
   ((eq ptr 'ivory) "processor")
   ((needs-processorstate-cast ptr member)
    (format nil "((PROCESSORSTATEP)~A)" (string-downcase ptr)))
   (t
    (if (stringp ptr) ptr (string-downcase ptr)))))

(defun structptr (str &optional member)
  (let ((new (remap-arg str)))
    (if new (check-needs-cast new member)
      (check-needs-cast str member))))

;;(defun gotolabel (str)
;;  (lc str))

(defun add-global-label-symbol (sym)
  (setq global-labels (append global-labels (list sym))))

(defun is-global-label (label)
  (if (equal label '|SetToCdrPushCarLocative|)
      t
    (if (equal label '|HALTMACHINE|)
	nil
      (member (if (stringp label) (intern label) label) global-labels))))

(defun gotolabel (str)
  (if (is-global-label str)
      str
    (lc str)))

; if number, return number+L, else return string
(defun longnum (str)
  (if (numberp str)
      (format nil "~AL" str)
    (string-downcase str)))

;
(setq call-label-count 0)

(defun make-call-label ()
    (setq call-label-count (+ 1 call-label-count))
    (format nil "return~4,'0D" call-label-count))

(setq just-start nil)
(setq global-labels nil)

;;;;
;; undo passthrus
(defun fix-passthrus nil
  (defmacro ldgp (&optional comment)
    `((ldgp $gp 0($27) ,@(if comment `(,comment)))))

  (defmacro divl (div by res &optional comment)
    `((divl ,div ,by ,res ,@(if comment `(,comment)))))

  (defmacro divq (div by res &optional comment)
    `((divq ,div ,by ,res ,@(if comment `(,comment)))))

  (defmacro divlu (div by res &optional comment)
    `((divlu ,div ,by ,res ,@(if comment `(,comment)))))

  (defmacro divqu (div by res &optional comment)
    `((m-divqu ,div ,by ,res ,@(if comment `(,comment)))))

  (defmacro reml (div by res &optional comment)
    `((reml ,div ,by ,res ,@(if comment `(,comment)))))

  (defmacro remlu (div by res &optional comment)
    `((remlu ,div ,by ,res ,@(if comment `(,comment)))))

  (defmacro remlq (div by res &optional comment)
    `((remlq ,div ,by ,res ,@(if comment `(,comment)))))

  (defmacro remqu (div by res &optional comment)
    `((remqu ,div ,by ,res ,@(if comment `(,comment)))))
  )
;;;;

;;
(defun emit-operation (form destination)
;; (format t "emit-operation: form ~S~%" form)
;;  (format t "~S~%" form)
  (let ((cmd (car form))
	(arg1 (car (cdr form)))
	(arg2 (car (cddr form)))
	(arg3 (car (cdddr form)))
	(arg4 (car (cddddr form))))
;; (format t "cmd: ~S~%" cmd)
  (case cmd
	(start
	 (setq just-start t)
	 (format destination "/* start ~A */~%~%" arg1))
	(end
	 (format destination "~%/* end ~A */~%" arg1))
	(comment
	 (format destination "  /* ~A */~%" arg1))

	(label
;;	 (format t "label: ~S~%" arg1)
	 (let ((lname (if (is-global-label arg1) arg1 (gotolabel arg1))))
	   (format destination "~%~A:~%" lname)
	   (format destination "  if (_trace) printf(\"~A:\\n\");~%" lname)
	   (if (equal lname "continuecurrentinstruction")
	       (format destination "  if (_show) show_loc();~%" lname))))

	(func-label
	 (format destination "~%~A:~%" arg1))

	(unlikely-label
	 (format destination "~%~A:~%" (gotolabel arg1)))

	(cache-ivory-state
	 (format destination "  /* cache-ivory-state */~%")
	 (format destination "  iCP = processor->cp;~%")
	 (format destination "  iPC = processor->epc;~%")
	 (format destination "  iSP = processor->sp;~%")
	 (format destination "  iFP = processor->fp;~%")
	 (format destination "  iLP = processor->lp;~%"))

	(ADDL
	 (check-comment arg4)
	 (cond
	  ((equal arg1 'zero)
	   (format destination "  ~A = (s32)~A;~%"
		   (fixarg arg3) (fixarg arg2)))
	  ((equal arg2 'zero)
	   (format destination "  ~A = (s32)~A;~%"
		   (fixarg arg3) (fixarg arg1)))
	  (t
	   (format destination "  ~A = (s32)~A + (s32)~A;~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2)))))

	(ADDL/V
	 (check-comment arg4)
	 (format destination
		 "  ~A = (u64)((s32)~A + (s64)(s32)~A); /* addl/v */~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination "  if (~A >> 32)~%    exception();~%"
		 (fixarg arg3)))

	(SUBL/V
	 (check-comment arg4)
	 (format destination
		 "  ~A = (s64)((s32)~A - (s64)(s32)~A); /* subl/v */~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination "  if (~A >> 32)~%    exception();~%"
		 (fixarg arg3)))

	(ADDQ
	 (check-comment arg4)
	 (cond
	  ((eq arg1 'zero)
	   (format destination "  ~A = ~A;~%" (fixarg arg3) (fixarg arg2)))
	  ((eq arg2 'zero)
	   (format destination "  ~A = ~A;~%" (fixarg arg3) (fixarg arg1)))
	  (t
	   (format destination "  ~A = ~A + ~A;~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2)))))

	('AND
	 (check-comment arg4)
	 (if (not (eq arg3 'zero))
	     (format destination "  ~A = ~A & ~A;~%"
		     (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(BIC
	 (check-comment arg4)
	 (format destination "  ~A = ~A & ~~~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (longnum arg2)
		 ))

	(BIS
	 (check-comment arg4)
	 (cond
	  ((eq arg1 'zero)
	   (format destination "  ~A = ~A;~%" (fixarg arg3) (fixarg arg2)))
	  ((eq arg2 'zero)
	   (format destination "  ~A = ~A;~%" (fixarg arg3) (fixarg arg1)))
	  (t
	   (format destination "  ~A = ~A | ~A;~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2)))))

	(BEQ
	 (check-comment arg3)
	 (format destination "  if (~A == 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BLE
	 (check-comment arg3)
	 (format destination "  if ((s64)~A <= 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BLT
	 (check-comment arg3)
	 (format destination "  if ((s64)~A < 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BLBC
	 (check-comment arg3)
	 (format destination "  if ((~A & 1) == 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BLBS
	 (check-comment arg3)
	 (format destination "  if (~A & 1)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BGE
	 (check-comment arg3)
	 (format destination "  if ((s64)~A >= 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BGT
	 (check-comment arg3)
	 (format destination "  if ((s64)~A > 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BNE
	 (check-comment arg3)
	 (format destination "  if (~A != 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BR
	 (check-comment arg4)
	 (format destination "  goto ~A;~%"
		 (gotolabel arg2)))

	(CLR
	 (check-comment arg2)
	 (format destination "  ~A = 0;~%"
		 (fixarg arg1)))

	(CMPBGE
	 (check-comment arg4)
	 (format destination "  ~A = CMPBGE(~A, ~A);~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPLE
	 (check-comment arg4)
	 (format destination "  ~A = ((s64)~A <= (s64)~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPEQ
	 (check-comment arg4)
	 (format destination "  ~A = (~A == ~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPLT
	 (check-comment arg4)
	 (format destination "  ~A = ((s64)~A < (s64)~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPTLE
	 (check-comment arg4)
	 (format destination
		 "  SETFLTT(~A,~A, FLTU64(~A,~A) <= FLTU64(~A,~A) ? 2.0:0);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(CMPTLT
	 (check-comment arg4)
	 (format destination
		 "  SETFLTT(~A,~A, FLTU64(~A,~A) < FLTU64(~A,~A) ? 2.0:0);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(CMPTEQ
	 (check-comment arg4)
	 (format destination
		 "  SETFLTT(~A,~A, FLTU64(~A,~A) == FLTU64(~A,~A) ? 2.0:0);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(CMPULE
	 (check-comment arg4)
	 (format destination "  ~A = ((u64)~A <= (u64)~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPULT
	 (check-comment arg4)
	 (format destination "  ~A = ((u64)~A < (u64)~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMOVLBS
	 (check-comment arg4)
	 (format destination "  if (~A & 1)~%"
		 (fixarg arg1))
	 (format destination "   ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVLBC
	 (check-comment arg4)
	 (format destination "  if ((~A & 1) == 0)~%"
		 (fixarg arg1))
	 (format destination "   ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVEQ
	 (check-comment arg4)
	 (format destination "  if (~A == 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVGE
	 (check-comment arg4)
	 (format destination "  if ((s64)~A >= 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVGT
	 (check-comment arg4)
	 (format destination "  if ((s64)~A > 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVLE
	 (check-comment arg4)
	 (format destination "  if ((s64)~A <= 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVLT
	 (check-comment arg4)
	 (format destination "  if ((s64)~A < 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVNE
	 (check-comment arg4)
	 (format destination "  if (~A)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CPYSN
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  CPYSN(~A, ~A, ~A, ~A, ~A, ~A);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTQL
	   (format destination "  CVTQL(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1)
		   (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTQL/V
	   (format destination "  CVTQLV(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTQS
	   (format destination "  CVTQS(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTQT
	   (format destination "  CVTQT(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTLQ
	   (format destination "  CVTLQ(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ
	   (format destination "  CVTTQ(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ/V
	   (format destination "  CVTTQV(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ/VC
	   (format destination "  CVTTQVC(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ/VM
	   (format destination "  CVTTQVM(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ/SVI
	   (format destination "  CVTTQSVI(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTS
	   (format destination "  CVTTS(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(M-DIVQU
	 (check-comment arg4)
	 (format destination "  ~A = ~A / ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(EXTERNAL-BRANCH
	 (format destination "  goto ~A;~%"
		 (gotolabel arg1)))

	(EXTBL
	 (check-comment arg4)
	 (if (eq arg2 0)
	     (format destination "  ~A = (u8)~A;~%"
		     (fixarg arg3) (fixarg arg1))
	   (format destination "  ~A = (u8)(~A >> ((~A&7)*8));~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(EXTWL
	 (check-comment arg4)
	 (if (eq arg2 0)
	     (format destination "  ~A = (u16)~A;~%"
		     (fixarg arg3) (fixarg arg1))
	   (format destination "  ~A = (u16)(~A >> ((~A&7)*8));~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(EXTLL
	 (check-comment arg4)
	 (if (eq arg2 0)
	     (format destination "  ~A = (u32)~A;~%"
		     (fixarg arg3) (fixarg arg1))
	   (format destination "  ~A = (u32)(~A >> ((~A&7)*8));~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(FBEQ
	 (check-comment arg3)
	 (format destination "  if (FLTU64(~A, ~A) == 0.0)~%    goto ~A;~%"
		 (regnum (fixarg arg1)) (fixarg arg1) 
		 (gotolabel arg2)))

	(FBLT
	 (check-comment arg3)
	 (format destination "  if (FLTU64(~A, ~A) < 0.0)~%    goto ~A;~%"
		 (regnum (fixarg arg1)) (fixarg arg1) 
		 (gotolabel arg2)))

	(FBGT
	 (check-comment arg3)
	 (format destination "  if (FLTU64(~A, ~A) > 0.0)~%    goto ~A;~%"
		 (regnum (fixarg arg1)) (fixarg arg1) 
		 (gotolabel arg2)))

	(FBNE
	 (check-comment arg3)
	 (format destination "  if (FLTU64(~A, ~A) != 0.0)~%    goto ~A;~%"
		 (regnum (fixarg arg1)) (fixarg arg1) 
		 (gotolabel arg2)))

	(FCMOVGT
	 (check-comment arg4)
	 (format destination "  if (FLTU64(~A, ~A) > 0.0)~%"
		 (regnum (fixarg arg1)) (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3) (fixarg arg2)))

	(FCMOVLT
	 (check-comment arg4)
	 (format destination "  if (FLTU64(~A, ~A) < 0.0)~%"
		 (regnum (fixarg arg1)) (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3) (fixarg arg2)))

	(INSBL
	 (check-comment arg4)
	 (format destination "  ~A = (~A & 0xff) << ((~A&7)*8);~%"
		 (fixarg arg3) (fixarg arg1) (fixarg arg2)))

	(JMP
	 (check-comment arg4)
	 (format destination "    goto *~A; /* jmp */~%"
		 (fixarg arg2)))

	(JSR
	 (check-comment arg4)
	 (format destination
		 "    r0 = (*( u64 (*)(u64, u64) )~A)(arg1, arg2); /* jsr */~%"
		 (fixarg arg2)))

	(FETCH)
	(FETCH_M)

	(LDA
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (cond
	  ((eq arg2 0)
	   (format destination "  ~A = ~A;~%"
		   (fixarg arg1) (fixarg arg3)))
	  ((or (numberp arg2) (isconstant arg2) (eq arg3 'zero))
	   (format destination "  ~A = ~A + ~A;~%"
		   (fixarg arg1) (fixarg arg3) (fixarg arg2)))
	  (t
	   (format destination "  ~A = (u64)&~A->~A;~%"
		   (fixarg arg1) (structptr arg3 arg2) (fixarg arg2)))))

	(LDAH
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (or (eq arg3 0) (eq arg3 'zero))
	     (format destination "  ~A = (~A) << 16;~%"
		     (fixarg arg1) (fixarg arg2))
	   (if (or (numberp arg2) (isconstant arg2))
	       (format destination "  ~A = ~A + ((~A) << 16);~%"
		       (fixarg arg1) (fixarg arg3) (fixarg arg2))
	     (format destination "  ~A = (u64)&~A->~A;~%"
		     (fixarg arg1) (structptr arg3 arg2) (fixarg arg2)))))

	(LDL
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  ~A = *(s32 *)~A;~%"
			 (fixarg arg1) (fixarg arg3))
	       (format destination "  ~A = *(s32 *)(~A + ~A);~%"
		       (fixarg arg1) (fixarg arg3) (fixarg arg2)))
	   ;; handle ugly x+4 case
	   (multiple-value-bind (ptr member offset)
				(decompose-args arg3 arg2)
		(if (numberp offset)
		    (progn
		      (if (eq (mod offset 4) 0)
			  (setq offset (/ offset 4))
			(format t "*** LDL, offset not mult 4; ~S" form)))
		  (setq offset (format nil "~A/4" offset)))
		(cond
		 ((eq offset 0)
		    (format destination "  ~A = *(s32 *)&~A->~A;~%"
			    (fixarg arg1) ptr (fixarg member)))
		 (t
		  (format destination "  ~A = *((s32 *)(&~A->~A)+~A);~%"
			  (fixarg arg1) ptr (fixarg member) offset))))))

	(LDQ
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (or (numberp arg2) (isconstant arg2))
	     (if (eq arg2 0)
		 (format destination "  ~A = *(u64 *)~A;~%"
			 (fixarg arg1) (fixarg arg3))
	       (format destination "  ~A = *(u64 *)(~A + ~A);~%"
		       (fixarg arg1) (fixarg arg3) (fixarg arg2)))
	   ;; member not number or constant
	   (let ((ptr (structptr arg3 arg2)))
	     ;; hack
	     (if (or
		  (equal ptr "((PROCESSORSTATEP)t8)")
		  (equal ptr "((PROCESSORSTATEP)t12)"))
		 (let ((asmoffset
			(cond
			 ((eq arg2 'PROCESSORSTATE_DATAREAD_MASK)
			  "PROCESSORSTATE_DATAREAD_MASK")
			 ((eq arg2 'PROCESSORSTATE_DATAREAD)
			  "PROCESSORSTATE_DATAREAD"))))
		   (format destination "  ~A = *(u64 *)(~A + ~A);~%"
			   (fixarg arg1) (fixarg arg3) asmoffset))
	       ;; normal case
	       (format destination "  ~A = *(u64 *)&(~A->~A);~%"
		       (fixarg arg1) ptr (fixarg arg2))))))

	(LDQ_U
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  ~A = LDQ_U(~A);~%"
		     (fixarg arg1) (fixarg arg3))
	   (format destination "  ~A = LDQ_U(&~A->~A);~%"
		   (fixarg arg1) (structptr arg3) (fixarg arg2))))

	(LDQ_L
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  ~A = *(u64 *)~A; /* lock */~%"
		     (fixarg arg1) (fixarg arg3))
	   (format destination "  ~A = *(u64 *)&(~A->~A); /* lock */~%"
		   (fixarg arg1) (structptr arg3) (fixarg arg2))))

	(LDS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  LDS(~A, ~A, *(u32 *)~A );~%"
		     (regnum (fixarg arg1)) (fixarg arg1) (fixarg arg3))
	   (format destination "  LDS(~A, ~A, ~A->~A);~%"
		   (regnum (fixarg arg1)) 
		   (fixarg arg1) (structptr arg3) (fixarg arg2))))

	(LDT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  LDT(~A, ~A, *(u32 *)~A );~%"
		     (regnum (fixarg arg1)) (fixarg arg1) (fixarg arg3))
	   (format destination "  LDT(~A, ~A, ~A->~A);~%"
		   (regnum (fixarg arg1)) 
		   (fixarg arg1) (structptr arg3) (fixarg arg2))))

	(STS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  STS( (u32 *)~A, ~A, ~A );~%"
			 (structptr arg3) (regnum (fixarg arg1)) (fixarg arg1))
	       (format destination "  STS( (u32 *)(~A + ~A), ~A, ~A );~%"
		       (structptr arg3 arg2) (fixarg arg2)
		       (regnum (fixarg arg1)) (fixarg arg1)))
	   (format destination "  STS( (u32 *)&~A->~A, ~A, ~A );~%"
		   (structptr arg3) (fixarg arg2)
		   (regnum (fixarg arg1)) (fixarg arg1))))

	(STT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  STT( (u64 *)~A, ~A, ~A );~%"
			 (structptr arg3) (regnum (fixarg arg1)) (fixarg arg1))
	       (format destination "  STT( (u64 *)(~A + ~A), ~A, ~A );~%"
		       (structptr arg3 arg2) (fixarg arg2)
		       (regnum (fixarg arg1)) (fixarg arg1)))
	   (format destination "  STT( (u64 *)&~A->~A, ~A, ~A );~%"
		   (structptr arg3) (fixarg arg2)
		   (regnum (fixarg arg1)) (fixarg arg1))))

	(ADDS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  ADDS(~A, ~A, ~A, ~A, ~A, ~A); /* adds */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(ADDT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  ADDT(~A, ~A, ~A, ~A, ~A, ~A); /* addt */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(SUBS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (not (equal arg3 'zero))
	     (format destination "  SUBS(~A, ~A, ~A, ~A, ~A, ~A); /* subs */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		     (regnum (fixarg arg1)) (fixarg arg1)
		     (regnum (fixarg arg2)) (fixarg arg2))))

	(SUBT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  SUBT(~A, ~A, ~A, ~A, ~A, ~A);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(MULS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  MULS(~A, ~A, ~A, ~A, ~A, ~A); /* muls */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(MULT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  MULT(~A, ~A, ~A, ~A, ~A, ~A);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(DIVS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  DIVS(~A, ~A, ~A, ~A, ~A, ~A); /* divs */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(DIVT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  DIVT(~A, ~A, ~A, ~A, ~A, ~A);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(LOAD-CONSTANT
	 (check-comment arg4)
	 (if (numberp arg2)
	     (format destination "  ~A = 0x~X;~%"
		     (fixarg arg1)
		     arg2)
	   (format destination "  ~A = ~A;~%"
		   (fixarg arg1)
		   (fixarg arg2))))

	(MSKBL
	 (check-comment arg4)
	 (format destination "  ~A = ~A & ~~(0xffL << (~A&7)*8);~%"
		 (fixarg arg3) (fixarg arg1) (fixarg arg2)))

	(MULQ
	 (check-comment arg4)
	 (format destination "  ~A = ~A * ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(MULL/V
	 (check-comment arg4)
	 (check-comment arg4)
	 (format destination
		 "  ~A = (s64)((s32)~A * (s64)(s32)~A); /* mull/v */~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination "  if (~A >> 32)~%    exception();~%"
		 (fixarg arg3)))

	(NOP)

	(ORNOT
	 (check-comment arg4)
	 (if (eq arg1 'zero)
	     (format destination "  ~A = ~~~A;~%"
		     (fixarg arg3) (fixarg arg2))
	   (format destination "  ~A = ~A | ~~(~A);~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(RPCC
	   (format destination "  ~A = RPCC();~%"
		   (fixarg arg1)))

	(SRA
	 (check-comment arg4)
	 (setq shiftarg 
	       (if (numberp arg2) (logand arg2 63)
		 (format nil "(~A & 63)" (fixarg arg2))))
	 (format destination "  ~A = (s64)~A >> ~A;~%"
		 (fixarg arg3) (fixarg arg1) shiftarg))

	(SRL
	 (check-comment arg4)
	 (setq shiftarg 
	       (if (numberp arg2) (logand arg2 63)
		 (format nil "(~A & 63)" (fixarg arg2))))
	 (format destination "  ~A = ~A >> ~A;~%"
		 (fixarg arg3) (fixarg arg1) shiftarg))

	(SLL
	 (check-comment arg4)
	 (setq shiftarg 
	       (if (numberp arg2) (logand arg2 63)
		 (format nil "(~A & 63)" (fixarg arg2))))
	 (format destination "  ~A = ~A << ~A;~%"
		 (fixarg arg3) (fixarg arg1) shiftarg))

	(SUBQ
	 (check-comment arg4)
	 (if (not (equal arg3 'zero))
	     (format destination "  ~A = ~A - ~A;~%"
		     (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(SUBL
	 (check-comment arg4)
	 (if (not (equal arg3 'zero))
	     (format destination "  ~A = (s32)~A - (s32)~A;~%"
		     (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(S4ADDQ
	 (check-comment arg4)
	 (if (equal arg2 'zero)
	     (format destination "  ~A = (~A * 4);~%"
		     (fixarg arg3) (fixarg arg1))
	   (format destination "  ~A = (~A * 4) + ~A;~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(S8ADDQ
	 (check-comment arg4)
	 (format destination "  ~A = (~A * 8) + ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(S4SUBQ
	 (check-comment arg4)
	 (format destination "  ~A = (~A * 4) - ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(S8SUBQ
	 (check-comment arg4)
	 (format destination "  ~A = (~A * 8) - ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(STL
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  *(u32 *)~A = ~A;~%"
			 (fixarg arg3) (fixarg arg1))
	       (format destination "  *(u32 *)(~A + ~A) = ~A;~%"
		       (fixarg arg3) (fixarg arg2) (fixarg arg1)))
	   ;; handle ugly x+4 case
	   (multiple-value-bind (ptr member offset)
				(decompose-args arg3 arg2)
		(if (numberp offset)
		    (progn
		      (if (eq (mod offset 4) 0)
			  (setq offset (/ offset 4))
			(format t "*** STL, offset not mult 4; ~S" form)))
		  (setq offset (format nil "~A/4" offset)))
		(cond
		 ((eq offset 0)
		  (format destination "  *(u32 *)&~A->~A = ~A;~%"
			  ptr (fixarg member) (fixarg arg1)))
		 (t
		  (format destination "  *((u32 *)(&~A->~A)+~A) = ~A;~%"
			  ptr (fixarg member) offset (fixarg arg1)))))))

	(STQ
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  *(u64 *)~A = ~A;~%"
			 (structptr arg3 arg2) (fixarg arg1))
	       (format destination "  *(u64 *)(~A + ~A) = ~A;~%"
		       (structptr arg3 arg2) (fixarg arg2) (fixarg arg1)))
	   ;; handle ugly x+4 case
	   (multiple-value-bind (ptr member offset)
				(decompose-args arg3 arg2)
		(if (numberp offset)
		    (progn
		      (if (eq (mod offset 8) 0)
			  (setq offset (/ offset 8))
			(format t "*** STQ, offset not mult 8; ~S" form)))
		  (setq offset (format nil "~A/8" offset)))
		(cond
		 ((eq offset 0)
		  ;; hack! two even!
		  (if (equal ptr "((PROCESSORSTATEP)arg1)")
		      (setq ptr "processor"))
		  ;;
		  (format destination "  *(u64 *)&~A->~A = ~A;~%"
			  ptr (fixarg member) (fixarg arg1)))
		 (t
		  (format destination "  *((u64 *)(&~A->~A)+~A) = ~A;~%"
			  ptr (fixarg member) offset (fixarg arg1)))))))

	(STQ_C
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  *(u64 *)&~A->~A = ~A; /* lock */~%"
		 (structptr arg3) (fixarg arg2) (fixarg arg1))
	 (format destination "  ~A = 1;~%"
		 (fixarg arg1)))

	(STQ_U
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  STQ_U(~A, ~A);~%"
		     (fixarg arg3)
		     (fixarg arg1))
	   (format destination "  STQ_U((u64)&~A->~A, ~A);~%"
		   (structptr arg3)
		   (fixarg arg2)
		   (fixarg arg1))))

	(TRAPB
	 (check-comment arg1)
	 (format destination "  /* trapb ~A */~%"
		 (fixarg arg1)))

	(XOR
	 (check-comment arg4)
	 (format destination "  ~A = ~A ^ ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	;-------------------------------------

	(CALL-SUBROUTINE
	 (setq label (make-call-label))
	 (format destination "  ~A = (u64)&&~A;~%" (fixarg arg1) label)
	 (format destination "  goto ~A;~%" (gotolabel arg2))
	 (format destination "~A:~%" label))

	(RET
	 (if (eq arg1 'zero)
	     (format destination "  goto *~A; /* ret */~%" (fixarg arg2))
	   (format t "*** RET w/arg1")))

	(TAGTYPE
	 (check-comment arg3)
	 (format destination "  ~A = ~A & 0x3f;~%"
		 (fixarg arg2)
		 (fixarg arg1)))

	(VM-READ
	 (setq arg5 (car (cdr (cddddr form))))
	 (format destination "  /* vm-read */~%")
	 (format destination "  ~A = (char *)ivory + ~A;~%"
		 (fixarg arg5) (fixarg arg1))
	 (format destination "  ~A = ~A << 2;~%"
		 (fixarg arg3) (fixarg arg5))
	 (format destination "  ~A = *(unsigned char *)~A;~%"
		 (fixarg arg2) (fixarg arg5))
	 (format destination "  ~A = *(u32 *)~A;~%"
		 (fixarg arg2) (fixarg arg2)))

	(PASSTHRU
	 (if (search ".globl" arg1)
	     (let ((split-list (split-by-one-space arg1)))
	       (add-global-label-symbol (intern (car (cdr split-list))))))
;;	 (format t "~S~%" global-labels)
;;	 (format t "passthru: arg1 ~S form ~S~%" arg1 form)
	 (if (or (equal (ext:substring arg1 0 5) "#ifde")
		 (equal (ext:substring arg1 0 5) "#ifnd")
		 (equal (ext:substring arg1 0 4) "#end"))
	     (format destination "~A~%" arg1)))
	     
	(otherwise
	 (format t "***UNKNOWN FORM: ~S~%" form))

	))
  1
  )

;;; PROCESS-ASM-FORM handles the expansion of assembler macros.  An
;;; assembler macro expands into a list of assembler operations any one of
;;; these may also be a macro The result of this loop is the linearization
;;; of assembler macros.
(defun process-asm-form (form destination &optional env)
; (format t "process-asm-form: form ~S~%" form)
  (if (consp (first form))
      (loop for meform in form
	    summing (process-asm-form meform destination env))
      (let ((expanded (macroexpand-careful form env)))
	(if (eq expanded form)
	    (emit-operation form destination)
	    (loop for meform in expanded
		  summing (process-asm-form meform destination env))))))


(defun process-asm-source (sourcefilename targetname)
  (with-open-file (sfs sourcefilename :direction :input)
    (with-open-file (tfs targetname :direction :output
				    :if-exists :supersede)
      (let ()
	(c-header tfs sourcefilename)
	(do ((form (read sfs nil :eof) (read sfs nil :eof)))
	    ((eq form :eof) nil)
	  (when (consp form) 
	    (process-asm-form form tfs)))
	(c-trailer tfs sourcefilename)))))

(defun create-output-files ()
  (setq count 0)
  (dolist (file '("ifunhead" "idispat" "ifuncom1" "ifuncom2"
 		  "ifungene" "ifunfcal" "ifunloop" "ifunlist"
 		  "ifuninst" "ifunmath" "ifunarra" "ifunmove"
 		  "ifunpred" "ifunsubp" "ifunfext" "ifunlexi"
 		  "ifunbits" "ifunblok" "ifunbind" "ifunfull"
 		  "ifunbnum" "ifuntrap" "ihalt" "idouble"
 		  "ifunjosh" "ifuntran"))
    (progn
      (setq count (+ 1 count))
      (setq outputfilename (format nil "xoutput~D" count))
      (setq inputfilename (format nil "../alpha-emulator/~A.as" file))
      (format t "INPUT: ~A~%" inputfilename)
      (format t "OUTPUT: ~A~%" outputfilename)
      (process-asm-source
       inputfilename
       outputfilename)))

  (format t "DONE:~%"))

(defun load-macros ()

  (load "clisp-support.lisp")
  (load "../emulator/aihead.lisp")
  (load "../emulator/errortbl.lisp")
  (load "../emulator/traps.lisp")
  (load "intrpmac.lisp")

  (load "../alpha-emulator/aistat.lisp")

  (dolist (file
	   '("alphamac"
;	     "intrpmac"
	     "stacklis"
	     "memoryem" "imaclist" "fcallmac" "imacbits"
	     "imacblok" "imaclexi" "imacgene" "imacinst" "imacialu"
	     "imacloop" "imacmath" "imacbind" "imacjosh" "imacarra"
	     "imacpred" "imacsubp" "imactrap"))
    (progn
      (setq filename (format nil "../alpha-emulator/~A.lisp" file))
      (load filename))))

(defun load-macros-old ()
  (load "clisp-support.lisp")
  (load "../emulator/aihead.lisp")
  (load "../emulator/errortbl.lisp")
  (load "intrpmac.lisp")
  (load "../alpha-emulator/aistat.lisp")
  (load "../alpha-emulator/alphamac.lisp")
  (load "../alpha-emulator/stacklis.lisp")
  (load "../alpha-emulator/imacloop.lisp")
  (load "../alpha-emulator/fcallmac.lisp")
  (load "../alpha-emulator/memoryem.lisp")
  (load "../alpha-emulator/imactrap.lisp")
  (load "../alpha-emulator/imacmath.lisp")
  (load "../alpha-emulator/imacsubp.lisp")
  (load "../alpha-emulator/imacblok.lisp")
  (load "../alpha-emulator/imacialu.lisp")
  (load "../alpha-emulator/imacbits.lisp")
  (load "../alpha-emulator/imacpred.lisp")
  (load "../alpha-emulator/imacarra.lisp")
  (load "../alpha-emulator/imacgene.lisp")
  (load "../alpha-emulator/imaclist.lisp")
  (load "../alpha-emulator/imacinst.lisp")
  (load "../alpha-emulator/imacbind.lisp"))

(defun add-missing-global-symbols ()

  (dolist (sym
	   '(
	     |ReadRegisterError|
	     |ReadRegisterFP|
	     |ReadRegisterLP|
	     |ReadRegisterSP|
	     |ReadRegisterError|
	     |ReadRegisterStackCacheLowerBound|
	     |ReadRegisterBARx|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterContinuation|
	     |ReadRegisterAluAndRotateControl|
	     |ReadRegisterControlRegister|
	     |ReadRegisterCRArgumentSize|
	     |ReadRegisterEphemeralOldspaceRegister|
	     |ReadRegisterZoneOldspaceRegister|
	     |ReadRegisterChipRevision|
	     |ReadRegisterFPCoprocessorPresent|
	     |ReadRegisterError|
	     |ReadRegisterPreemptRegister|
	     |ReadRegisterIcacheControl|
	     |ReadRegisterPrefetcherControl|
	     |ReadRegisterMapCacheControl|
	     |ReadRegisterMemoryControl|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterStackCacheOverflowLimit|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterMicrosecondClock|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterTOS|
	     |ReadRegisterEventCount|
	     |ReadRegisterBindingStackPointer|
	     |ReadRegisterCatchBlockList|
	     |ReadRegisterControlStackLimit|
	     |ReadRegisterControlStackExtraLimit|
	     |ReadRegisterBindingStackLimit|
	     |ReadRegisterPHTBase|
	     |ReadRegisterPHTMask|
	     |ReadRegisterCountMapReloads|
	     |ReadRegisterListCacheArea|
	     |ReadRegisterListCacheAddress|
	     |ReadRegisterListCacheLength|
	     |ReadRegisterStructureCacheArea|
	     |ReadRegisterStructureCacheAddress|
	     |ReadRegisterStructureCacheLength|
	     |ReadRegisterDynamicBindingCacheBase|
	     |ReadRegisterDynamicBindingCacheMask|
	     |ReadRegisterChoicePointer|
	     |ReadRegisterStructureStackChoicePointer|
	     |ReadRegisterFEPModeTrapVectorAddress|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterStackFrameMaximumSize|
	     |ReadRegisterStackCacheDumpQuantum|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterConstantNIL|
	     |ReadRegisterConstantT|
	     |WriteRegisterError|
	     |WriteRegisterFP|
	     |WriteRegisterLP|
	     |WriteRegisterSP|
	     |WriteRegisterError|
	     |WriteRegisterStackCacheLowerBound|
	     |WriteRegisterBARx|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterContinuation|
	     |WriteRegisterAluAndRotateControl|
	     |WriteRegisterControlRegister|
	     |WriteRegisterError|
	     |WriteRegisterEphemeralOldspaceRegister|
	     |WriteRegisterZoneOldspaceRegister|
	     |WriteRegisterError|
	     |WriteRegisterFPCoprocessorPresent|
	     |WriteRegisterError|
	     |WriteRegisterPreemptRegister|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterStackCacheOverflowLimit|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterTOS|
	     |WriteRegisterEventCount|
	     |WriteRegisterBindingStackPointer|
	     |WriteRegisterCatchBlockList|
	     |WriteRegisterControlStackLimit|
	     |WriteRegisterControlStackExtraLimit|
	     |WriteRegisterBindingStackLimit|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterListCacheArea|
	     |WriteRegisterListCacheAddress|
	     |WriteRegisterListCacheLength|
	     |WriteRegisterStructureCacheArea|
	     |WriteRegisterStructureCacheAddress|
	     |WriteRegisterStructureCacheLength|
	     |WriteRegisterDynamicBindingCacheBase|
	     |WriteRegisterDynamicBindingCacheMask|
	     |WriteRegisterChoicePointer|
	     |WriteRegisterStructureStackChoicePointer|
	     |WriteRegisterFEPModeTrapVectorAddress|
	     |WriteRegisterError|
	     |WriteRegisterMappingTableCache|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     ))
    (add-global-label-symbol sym)))


(defun build ()
;  (load-macros-old)
  (load-macros)
  (fix-passthrus)
  (add-missing-global-symbols)
  (create-output-files)
)

(build)

;(process-asm-source "input1" "output")
;(process-asm-source "../alpha-emulator/ifunhead.as" "output1")
;(process-asm-source "../alpha-emulator/idispat.as" "output2")
