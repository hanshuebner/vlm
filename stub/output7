/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunloop.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* Branch and loop instructions. */
/* start DoBranchTrueElseNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueElseNoPop */

dobranchtrueelsenopop:
  if (_trace) printf("dobranchtrueelsenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueElseNoPopIM:
  if (_trace) printf("DoBranchTrueElseNoPopIM:\n");

DoBranchTrueElseNoPopSP:
  if (_trace) printf("DoBranchTrueElseNoPopSP:\n");

DoBranchTrueElseNoPopLP:
  if (_trace) printf("DoBranchTrueElseNoPopLP:\n");

DoBranchTrueElseNoPopFP:
  if (_trace) printf("DoBranchTrueElseNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 == 0)
    goto NEXTINSTRUCTION;
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 8;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchTrueElseNoPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueElseNoPop */
/* start DoBranchTrueElseExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueElseExtraPop */

dobranchtrueelseextrapop:
  if (_trace) printf("dobranchtrueelseextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueElseExtraPopIM:
  if (_trace) printf("DoBranchTrueElseExtraPopIM:\n");

DoBranchTrueElseExtraPopSP:
  if (_trace) printf("DoBranchTrueElseExtraPopSP:\n");

DoBranchTrueElseExtraPopLP:
  if (_trace) printf("DoBranchTrueElseExtraPopLP:\n");

DoBranchTrueElseExtraPopFP:
  if (_trace) printf("DoBranchTrueElseExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 != 0)
    goto dobrelsepopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 16;
  goto cachevalid;

dobrelsepopextrapop:
  if (_trace) printf("dobrelsepopextrapop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 8;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchTrueElseExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueElseExtraPop */
/* start DoBranchFalseElseExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseElseExtraPop */

dobranchfalseelseextrapop:
  if (_trace) printf("dobranchfalseelseextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseElseExtraPopIM:
  if (_trace) printf("DoBranchFalseElseExtraPopIM:\n");

DoBranchFalseElseExtraPopSP:
  if (_trace) printf("DoBranchFalseElseExtraPopSP:\n");

DoBranchFalseElseExtraPopLP:
  if (_trace) printf("DoBranchFalseElseExtraPopLP:\n");

DoBranchFalseElseExtraPopFP:
  if (_trace) printf("DoBranchFalseElseExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 == 0)
    goto dobrnelsepopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 16;
  goto cachevalid;

dobrnelsepopextrapop:
  if (_trace) printf("dobrnelsepopextrapop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 8;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchFalseElseExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseElseExtraPop */
/* start DoBranchFalseExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseExtraPop */

dobranchfalseextrapop:
  if (_trace) printf("dobranchfalseextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseExtraPopIM:
  if (_trace) printf("DoBranchFalseExtraPopIM:\n");

DoBranchFalseExtraPopSP:
  if (_trace) printf("DoBranchFalseExtraPopSP:\n");

DoBranchFalseExtraPopLP:
  if (_trace) printf("DoBranchFalseExtraPopLP:\n");

DoBranchFalseExtraPopFP:
  if (_trace) printf("DoBranchFalseExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 == 0)
    goto dobrnpopelsepopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 16;
  goto cachevalid;

dobrnpopelsepopextrapop:
  if (_trace) printf("dobrnpopelsepopextrapop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 16;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchFalseExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseExtraPop */
/* start DoLoopDecrementTos */

  /* Halfword 10 bit immediate instruction - DoLoopDecrementTos */

doloopdecrementtos:
  if (_trace) printf("doloopdecrementtos:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoLoopDecrementTosIM:
  if (_trace) printf("DoLoopDecrementTosIM:\n");

DoLoopDecrementTosSP:
  if (_trace) printf("DoLoopDecrementTosSP:\n");

DoLoopDecrementTosLP:
  if (_trace) printf("DoLoopDecrementTosLP:\n");

DoLoopDecrementTosFP:
  if (_trace) printf("DoLoopDecrementTosFP:\n");
  arg1 = (s64)arg3 >> 48;
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  t2 = (u32)arg6;
  t3 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t3 = t3 & 63;
  if (t3 != 0)
    goto g7179;
  t3 = (s32)t2 - (s32)1;
  t4 = ((s64)t3 < (s64)t2) ? 1 : 0;
  if (t4 == 0)
    goto g7181;
  t6 = Type_Fixnum;
  *(u32 *)iSP = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  if ((s64)t3 <= 0)
    goto NEXTINSTRUCTION;
  /* Here if branch taken. */
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

g7179:
  if (_trace) printf("g7179:\n");
  t3 = t1 - Type_Fixnum;
  /* Strip CDR code, low bits */
  t3 = t3 & 56;
  if (t3 != 0)
    goto g7180;

g7181:
  if (_trace) printf("g7181:\n");
  /* Compute next-pc */
  arg5 = iPC + arg1;
  /* arg3 = stackp */
  arg3 = 1;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto loopexception;

g7180:
  if (_trace) printf("g7180:\n");
  arg5 = 0;
  arg2 = 81;
  goto illegaloperand;

/* end DoLoopDecrementTos */
  /* End of Halfword operand from stack instruction - DoLoopDecrementTos */
/* start DoLoopIncrementTosLessThan */

  /* Halfword 10 bit immediate instruction - DoLoopIncrementTosLessThan */

doloopincrementtoslessthan:
  if (_trace) printf("doloopincrementtoslessthan:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoLoopIncrementTosLessThanIM:
  if (_trace) printf("DoLoopIncrementTosLessThanIM:\n");

DoLoopIncrementTosLessThanSP:
  if (_trace) printf("DoLoopIncrementTosLessThanSP:\n");

DoLoopIncrementTosLessThanLP:
  if (_trace) printf("DoLoopIncrementTosLessThanLP:\n");

DoLoopIncrementTosLessThanFP:
  if (_trace) printf("DoLoopIncrementTosLessThanFP:\n");
  arg1 = (s64)arg3 >> 48;
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  t2 = (u32)arg6;
  t5 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g7182;
  /* Get arg1. */
  t4 = *(s32 *)(iSP + -8);
  t3 = *(s32 *)(iSP + -4);
  t4 = (u32)t4;
  t5 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g7183;
  t5 = (s32)t2 + (s32)1;
  t6 = ((s64)t2 <= (s64)t5) ? 1 : 0;
  if (t6 == 0)
    goto g7184;
  t6 = Type_Fixnum;
  *(u32 *)iSP = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  t6 = ((s64)t5 <= (s64)t4) ? 1 : 0;
  if (t6 == 0)
    goto NEXTINSTRUCTION;
  /* Here if branch taken. */

g7186:
  if (_trace) printf("g7186:\n");
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

g7182:
  if (_trace) printf("g7182:\n");
  t5 = t1 - Type_Fixnum;
  /* Strip CDR code, low bits */
  t5 = t5 & 56;
  if (t5 != 0)
    goto g7185;

g7183:
  if (_trace) printf("g7183:\n");
  t5 = t3 - Type_Fixnum;
  /* Strip CDR code, low bits */
  t5 = t5 & 56;
  if (t5 != 0)
    goto g7185;

g7184:
  if (_trace) printf("g7184:\n");
  /* Compute next-pc */
  arg5 = iPC + arg1;
  /* arg3 = stackp */
  arg3 = 1;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto loopexception;

g7185:
  if (_trace) printf("g7185:\n");
  arg5 = 0;
  arg2 = 16;
  goto illegaloperand;

/* end DoLoopIncrementTosLessThan */
  /* End of Halfword operand from stack instruction - DoLoopIncrementTosLessThan */
/* start DoBranchTrueExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueExtraPop */

dobranchtrueextrapop:
  if (_trace) printf("dobranchtrueextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueExtraPopIM:
  if (_trace) printf("DoBranchTrueExtraPopIM:\n");

DoBranchTrueExtraPopSP:
  if (_trace) printf("DoBranchTrueExtraPopSP:\n");

DoBranchTrueExtraPopLP:
  if (_trace) printf("DoBranchTrueExtraPopLP:\n");

DoBranchTrueExtraPopFP:
  if (_trace) printf("DoBranchTrueExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 != 0)
    goto dobrpopelsepopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 16;
  goto cachevalid;

dobrpopelsepopextrapop:
  if (_trace) printf("dobrpopelsepopextrapop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 16;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchTrueExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueExtraPop */
/* start DoBranchTrueAndNoPopElseNoPopExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueAndNoPopElseNoPopExtraPop */

dobranchtrueandnopopelsenopopextrapop:
  if (_trace) printf("dobranchtrueandnopopelsenopopextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueAndNoPopElseNoPopExtraPopIM:
  if (_trace) printf("DoBranchTrueAndNoPopElseNoPopExtraPopIM:\n");

DoBranchTrueAndNoPopElseNoPopExtraPopSP:
  if (_trace) printf("DoBranchTrueAndNoPopElseNoPopExtraPopSP:\n");

DoBranchTrueAndNoPopElseNoPopExtraPopLP:
  if (_trace) printf("DoBranchTrueAndNoPopElseNoPopExtraPopLP:\n");

DoBranchTrueAndNoPopElseNoPopExtraPopFP:
  if (_trace) printf("DoBranchTrueAndNoPopElseNoPopExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 != 0)
    goto dobrextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 8;
  goto cachevalid;

dobrextrapop:
  if (_trace) printf("dobrextrapop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 8;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchTrueAndNoPopElseNoPopExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueAndNoPopElseNoPopExtraPop */
/* start DoBranchFalseAndNoPopElseNoPopExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseAndNoPopElseNoPopExtraPop */

dobranchfalseandnopopelsenopopextrapop:
  if (_trace) printf("dobranchfalseandnopopelsenopopextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseAndNoPopElseNoPopExtraPopIM:
  if (_trace) printf("DoBranchFalseAndNoPopElseNoPopExtraPopIM:\n");

DoBranchFalseAndNoPopElseNoPopExtraPopSP:
  if (_trace) printf("DoBranchFalseAndNoPopElseNoPopExtraPopSP:\n");

DoBranchFalseAndNoPopElseNoPopExtraPopLP:
  if (_trace) printf("DoBranchFalseAndNoPopElseNoPopExtraPopLP:\n");

DoBranchFalseAndNoPopElseNoPopExtraPopFP:
  if (_trace) printf("DoBranchFalseAndNoPopElseNoPopExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 == 0)
    goto dobrnextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 8;
  goto cachevalid;

dobrnextrapop:
  if (_trace) printf("dobrnextrapop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 8;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchFalseAndNoPopElseNoPopExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseAndNoPopElseNoPopExtraPop */
/* start BranchException */


branchexception:
  if (_trace) printf("branchexception:\n");
  arg5 = 0;
  arg2 = 24;
  goto illegaloperand;

/* end BranchException */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunloop.as */
