/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifuncom1.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* The most commonly used instructions, part 1.  */
/* start DoPush */

  /* Halfword operand from stack instruction - DoPush */
  /* arg2 has the preloaded 8 bit operand. */

dopush:
  if (_trace) printf("dopush:\n");
#ifdef TRACING
#endif

DoPushSP:
  if (_trace) printf("DoPushSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindopush;
#endif

DoPushLP:
  if (_trace) printf("DoPushLP:\n");
#ifdef TRACING
  goto begindopush;
#endif

DoPushFP:
  if (_trace) printf("DoPushFP:\n");

begindopush:
  if (_trace) printf("begindopush:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Push the new value */
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Get the tag/data */
  t1 = *(s32 *)(arg1 + 4);
  t2 = *(s32 *)arg1;
  /* Store the data word */
  *(u32 *)iSP = t2;

g6142:
  if (_trace) printf("g6142:\n");
  /* TagType. */
  /* make it CDR NEXT */
  t1 = t1 & 63;
  /* Store the TAG - this *DOES* dual issue! */
  *(u32 *)(iSP + 4) = t1;

/* end DoPush */
  /* End of Halfword operand from stack instruction - DoPush */
/* start nextInstruction */


nextinstruction:
  if (_trace) printf("nextinstruction:\n");

cachevalid:
  if (_trace) printf("cachevalid:\n");
  /* Grab the instruction/operand while stalled */
  arg3 = *(u64 *)&(((CACHELINEP)iCP)->instruction);
  /* Assume FP mode */
  arg1 = iFP;
  /* Get the PC to check cache hit. */
  t2 = *(u64 *)&(((CACHELINEP)iCP)->pcdata);
  /* SP-pop mode constant */
  arg4 = iSP + -8;

continuecurrentinstruction:
  if (_trace) printf("continuecurrentinstruction:\n");
  if (_show) show_loc();
  /* Instruction handler */
  t3 = *(u64 *)&(((CACHELINEP)iCP)->code);
  /* SP mode constant */
  arg5 = iSP + -2040;
  /* Need this in case we take a trap */
  *(u64 *)&processor->restartsp = iSP;
  /* Get the mode bits */
  t4 = (u8)(arg3 >> ((5&7)*8));
  /* check for HIT. */
  t2 = t2 - iPC;
  /* Load TOS in free di slot */
  arg6 = *(u64 *)iSP;
  /* Extract (8-bit, unsigned) operand */
  arg2 = (u8)(arg3 >> ((4&7)*8));
  /* PC didn't match, take a cache miss */
  if (t2 != 0)
    goto takeicachemiss;
  /* LP or Immediate mode */
  if (t4 & 1)
   arg1 = iLP;
#ifdef TRACING
  /* Update the instruction count. */
  t4 = *(u64 *)&(processor->instruction_count);
  /* Decrement the instruction count. */
  t4 = t4 - 1;
  /* J. if not reached stop point. */
  if (t4 != 0)
    goto g6196;
  /* put a breakpoint here to catch stops */
  zero = zero;

g6196:
  if (_trace) printf("g6196:\n");
  *(u64 *)&processor->instruction_count = t4;
  /* Trace instructions if requested. */
  t4 = *(u64 *)&(processor->trace_hook);
  /* J. if not tracing. */
  if (t4 == 0)
    goto g6201;
  /* Record an instruction trace entry */
  t5 = *(s32 *)&t4->tracedata_recording_p;
  t6 = *(u64 *)&(t4->tracedata_start_pc);
  /* Jump if recording is on */
  if (t5 != 0)
    goto g6197;
  /* Turn recording on if at the start PC */
  t6 = (t6 == iPC) ? 1 : 0;
  *(u32 *)&t4->tracedata_recording_p = t6;
  /* Jump if not at the start PC */
  if (t6 == 0)
    goto g6201;

g6197:
  if (_trace) printf("g6197:\n");
  /* Get address of next trace record  */
  t5 = *(u64 *)&(t4->tracedata_current_entry);
  t6 = *(u64 *)&(processor->instruction_count);
  /* Save current PC */
  *(u64 *)&t5->tracerecord_epc = iPC;
  /* Save instruction count */
  *(u64 *)&t5->tracerecord_counter = t6;
  t6 = *(u64 *)iSP;
  /* Convert stack cache address to VMA */
  t8 = *(u64 *)&(processor->stackcachedata);
  t7 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t8 = iSP - t8;
  /* convert byte address to word address */
  t8 = t8 >> 3;
  /* reconstruct VMA */
  t7 = t8 + t7;
  /* Save current value of TOS */
  *(u64 *)&t5->tracerecord_tos = t6;
  /* Save current SP */
  *(u64 *)&t5->tracerecord_sp = t7;
  t6 = *(s32 *)&((CACHELINEP)iCP)->operand;
  t7 = *(u64 *)&(((CACHELINEP)iCP)->code);
  /* Save current instruction's operand */
  *(u32 *)&t5->tracerecord_operand = t6;
  /* Save pointer to current instruction code */
  *(u64 *)&t5->tracerecord_instruction = t7;
  t7 = *(u64 *)&(processor->control);
  t8 = *(u64 *)&(((CACHELINEP)iCP)->instruction);
  /* We don't yet record catch blocks */
  *(u32 *)&t5->tracerecord_catch_block_p = zero;
  /* Save control register */
  *(u64 *)&t5->tracerecord_catch_block_0 = t7;
  t6 = *(u64 *)&(processor->tvi);
  /* Save full word instruction operand */
  *(u64 *)&t5->tracerecord_instruction_data = t8;
  /* Save trap indiciator */
  *(u32 *)&t5->tracerecord_trap_p = t6;
  /* Jump if didn't trap */
  if (t6 == 0)
    goto g6198;
  t6 = *(u64 *)(iFP + 16);
  /* Zero flag to avoid false trap entries */
  *(u64 *)&processor->tvi = zero;
  t7 = *(u64 *)(iFP + 24);
  /* Save trap vector index */
  *(u64 *)&t5->tracerecord_trap_data_0 = t6;
  t8 = *(u64 *)(iFP + 32);
  /* Save fault PC */
  *(u64 *)&t5->tracerecord_trap_data_1 = t7;
  t9 = *(u64 *)(iFP + 40);
  /* Save two additional arguments */
  *(u64 *)&t5->tracerecord_trap_data_2 = t8;
  *(u64 *)&t5->tracerecord_trap_data_3 = t9;

g6198:
  if (_trace) printf("g6198:\n");
  /* Bump to next trace record */
  t5 = t5 + tracerecordsize;
  /* Get pointer to start of trace records */
  t6 = *(u64 *)&(t4->tracedata_records_start);
  /* Set record pointer to keep printer happy */
  *(u64 *)&t4->tracedata_current_entry = t5;
  /* Get pointer to end of trace record */
  t7 = *(u64 *)&(t4->tracedata_records_end);
  /* Function to print trace if non-zero */
  t8 = *(u64 *)&(t4->tracedata_printer);
  /* Non-zero iff we're about to wrap the circular buffer */
  t7 = ((s64)t7 <= (s64)t5) ? 1 : 0;
  /* Update next record pointer iff we wrapped */
  if (t7)
    t5 = t6;
  /* Don't print if we didn't wrap */
  if (t7 == 0)
    t8 = zero;
  /* Jump if we don't need to print */
  if (t8 == 0)
    goto g6199;
  *(u64 *)&processor->cp = iCP;
  *(u64 *)&processor->epc = iPC;
  *(u64 *)&processor->sp = iSP;
  *(u64 *)&processor->fp = iFP;
  *(u64 *)&processor->lp = iLP;
  *(u64 *)&processor->asrf2 = arg1;
  *(u64 *)&processor->asrf3 = arg2;
  *(u64 *)&processor->asrf4 = arg3;
  *(u64 *)&processor->asrf5 = arg4;
  *(u64 *)&processor->asrf6 = arg5;
  *(u64 *)&processor->asrf7 = arg6;
  *(u64 *)&processor->asrf8 = t4;
  *(u64 *)&processor->asrf9 = t5;
  *(u64 *)&processor->long_pad1 = t3;
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  pv = t8;
    r0 = (*( u64 (*)(u64, u64) )t8)(arg1, arg2); /* jsr */
  r9 = *(u64 *)&(processor->asrr9);
  r10 = *(u64 *)&(processor->asrr10);
  r11 = *(u64 *)&(processor->asrr11);
  r12 = *(u64 *)&(processor->asrr12);
  r13 = *(u64 *)&(processor->asrr13);
  r15 = *(u64 *)&(processor->asrr15);
  r27 = *(u64 *)&(processor->asrr27);
  r29 = *(u64 *)&(processor->asrr29);
  arg1 = *(u64 *)&(processor->asrf2);
  arg2 = *(u64 *)&(processor->asrf3);
  arg3 = *(u64 *)&(processor->asrf4);
  arg4 = *(u64 *)&(processor->asrf5);
  arg5 = *(u64 *)&(processor->asrf6);
  arg6 = *(u64 *)&(processor->asrf7);
  t4 = *(u64 *)&(processor->asrf8);
  t5 = *(u64 *)&(processor->asrf9);
  t3 = *(u64 *)&(processor->long_pad1);
  iCP = *(u64 *)&(processor->cp);
  iPC = *(u64 *)&(processor->epc);
  iSP = *(u64 *)&(processor->sp);
  iFP = *(u64 *)&(processor->fp);
  iLP = *(u64 *)&(processor->lp);
  /* Claim we didn't wrap */
  t7 = zero;

g6199:
  if (_trace) printf("g6199:\n");
  /* Save next record pointer */
  *(u64 *)&t4->tracedata_current_entry = t5;
  /* Jump if we didn't wrap */
  if (t7 == 0)
    goto g6200;
  /* Set flag indicating that we wrapped */
  *(u32 *)&t4->tracedata_wrap_p = t7;

g6200:
  if (_trace) printf("g6200:\n");
  t5 = *(u64 *)&(t4->tracedata_stop_pc);
  /* Non-zero if at PC where we should stop tracing */
  t5 = (t5 == iPC) ? 1 : 0;
  /* Non-zero if not at the PC */
  t5 = (t5 == 0) ? 1 : 0;
  /* Update recording flag */
  *(u32 *)&t4->tracedata_recording_p = t5;

g6201:
  if (_trace) printf("g6201:\n");
#endif
#ifdef STATISTICS
  /* The instruction. */
  t4 = *(u64 *)&(((CACHELINEP)iCP)->code);
  /* The usage statistics array */
  t5 = *(u64 *)&(processor->statistics);
  t9 = zero + 8191;
  t6 = t4 >> 4;
  /* Extract the address */
  t6 = t6 & t9;
  /* Compute the index to the usage data for this instn. */
  t7 = (t6 * 4) + t5;
  /* Get current usage data */
  t8 = *(s32 *)t7;
  /* Increment */
  t8 = t8 + 1;
  /* Set current usage data */
  *(u32 *)t7 = t8;
#endif
#ifdef CACHEMETERING
  /* The number of remaining tokens. */
  t5 = *(s32 *)&processor->metercount;
  /* The cache miss meter buffer. */
  t4 = *(u64 *)&(processor->meterdatabuff);
  /* Position for new data. */
  t7 = *(s32 *)&processor->meterpos;
  /* record a cache hit */
  t5 = t5 - 1;
  if (t5 != 0)
    goto g6202;
  t8 = *(s32 *)&processor->metermask;
  /* position of the current data item */
  t4 = (t7 * 4) + t4;
  t9 = *(s32 *)&processor->metervalue;
  t7 = t7 + 1;
  t7 = t7 & t8;
  t8 = *(s32 *)&processor->metermax;
  t6 = t9 - t8;
  if ((s64)t6 > 0)
    t8 = t9;
  *(u32 *)&processor->metermax = t8;
  /* store the datapoint */
  *(u32 *)t4 = t9;
  /* Position for new data. */
  *(u32 *)&processor->meterpos = t7;
  *(u32 *)&processor->metervalue = zero;
  t5 = *(s32 *)&processor->meterfreq;

g6202:
  if (_trace) printf("g6202:\n");
  *(u32 *)&processor->metercount = t5;
#endif
#ifdef DEBUGGING
  /* Just in case... */
  if (t3 == 0)
    goto haltmachine;
#endif
  /* Jump to the handler */
    goto *t3; /* jmp */
  /* Here to advance the PC and begin a new instruction.  Most */
  /* instructions come here when they have finished.  Instructions */
  /* that explicitly update the PC (and CP) go to interpretInstruction. */

NEXTINSTRUCTION:
  if (_trace) printf("NEXTINSTRUCTION:\n");
  /* Load the next PC from the cache */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Advance cache position */
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

takeicachemiss:
  if (_trace) printf("takeicachemiss:\n");
  goto ICACHEMISS;

/* end nextInstruction */
/* start DoPushImmediateHandler */


dopushimmediatehandler:
  if (_trace) printf("dopushimmediatehandler:\n");
#ifdef TRACING
  goto DoPushIM;
#endif

DoPushIM:
  if (_trace) printf("DoPushIM:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t4 = Type_Fixnum;
  /* Push it with CDR-NEXT onto the stack */
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto cachevalid;

/* end DoPushImmediateHandler */
/* start DoBranchTrue */

  /* Halfword 10 bit immediate instruction - DoBranchTrue */

dobranchtrue:
  if (_trace) printf("dobranchtrue:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueIM:
  if (_trace) printf("DoBranchTrueIM:\n");

DoBranchTrueSP:
  if (_trace) printf("DoBranchTrueSP:\n");

DoBranchTrueLP:
  if (_trace) printf("DoBranchTrueLP:\n");

DoBranchTrueFP:
  if (_trace) printf("DoBranchTrueFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 != 0)
    goto dobrpopelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 8;
  goto cachevalid;

dobrpopelsepop:
  if (_trace) printf("dobrpopelsepop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 8;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchTrue */
  /* End of Halfword operand from stack instruction - DoBranchTrue */
/* start DoBranchFalse */

  /* Halfword 10 bit immediate instruction - DoBranchFalse */

dobranchfalse:
  if (_trace) printf("dobranchfalse:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseIM:
  if (_trace) printf("DoBranchFalseIM:\n");

DoBranchFalseSP:
  if (_trace) printf("DoBranchFalseSP:\n");

DoBranchFalseLP:
  if (_trace) printf("DoBranchFalseLP:\n");

DoBranchFalseFP:
  if (_trace) printf("DoBranchFalseFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 == 0)
    goto dobrnpopelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 8;
  goto cachevalid;

dobrnpopelsepop:
  if (_trace) printf("dobrnpopelsepop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 8;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchFalse */
  /* End of Halfword operand from stack instruction - DoBranchFalse */
/* start DoReturnSingle */

  /* Halfword 10 bit immediate instruction - DoReturnSingle */

doreturnsingle:
  if (_trace) printf("doreturnsingle:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoReturnSingleIM:
  if (_trace) printf("DoReturnSingleIM:\n");

DoReturnSingleSP:
  if (_trace) printf("DoReturnSingleSP:\n");

DoReturnSingleLP:
  if (_trace) printf("DoReturnSingleLP:\n");

DoReturnSingleFP:
  if (_trace) printf("DoReturnSingleFP:\n");
  /* arg1 has operand preloaded. */
  /* Fetch value based on immediate, interleaved with compute disposition dispatch */
  arg5 = *(s32 *)&processor->control;
  /* Clear cdr */
  arg3 = arg6 << 26;
  t3 = (12) << 16;
  t1 = *(u64 *)&(processor->niladdress);
  /* Clear cdr */
  arg3 = arg3 >> 26;
  t2 = *(u64 *)&(processor->taddress);
  /* mask disposition bits */
  t3 = t3 & arg5;
  /* shift disposition bits into place */
  t3 = t3 >> 18;
  arg6 = *(u64 *)&(processor->stackcachedata);
  /* arg2 is 8 bits of "kludge operand" 0=TOS 40=NIL 41=T */
  if ((s64)arg2 > 0)
    arg3 = t1;
  /* arg4 -2=effect -1=value 0=return 1=multiple */
  arg4 = t3 - 2;
  if (arg2 & 1)
   arg3 = t2;

returncommontail:
  if (_trace) printf("returncommontail:\n");
  /* Restore machine state from frame header. */
  t3 = *(s32 *)iFP;
  t1 = (1792) << 16;
  t5 = *(s32 *)&processor->continuation;
  /* Mask */
  t1 = arg5 & t1;
  t2 = *(s32 *)(iFP + 4);
  t7 = iCP;
  /* Need to cleanup frame first */
  if (t1 != 0)
    goto returnsinglecleanup;
  t3 = (u32)t3;
  t4 = *((s32 *)(&processor->continuation)+1);
  t5 = (u32)t5;
#ifdef IVERIFY
  /* check for instruction verification suite end-of-test */
  /* check for end of run */
  t6 = (s32)t2 - (s32)Type_NIL;
  if (t6 == 0)
    goto g6227;
#endif
  /* Get saved control register */
  t6 = *(s32 *)(iFP + 8);
  /* TagType. */
  t2 = t2 & 63;
  /* Restore the PC. */
  if (arg4 == 0)
    goto g6229;
  /* Assume even PC */
  iPC = t5 << 1;
  t1 = t4 & 1;
  t7 = *(u64 *)&(processor->continuationcp);
  iPC = iPC + t1;

g6229:
  if (_trace) printf("g6229:\n");
  /* Restore the saved continuation */
  *((u32 *)(&processor->continuation)+1) = t2;
  /* Get the caller frame size into place */
  t1 = arg5 >> 9;
  *(u32 *)&processor->continuation = t3;
  /* Restore the stack pointer. */
  iSP = iFP - 8;
  *(u64 *)&processor->continuationcp = zero;
  /* Mask just the caller frame size. */
  t1 = t1 & 255;
  /* *8 */
  t1 = (t1 * 8) + 0;
  t2 = (2048) << 16;
  t2 = t2 & arg5;
  /* Get the preempt-pending bit */
  t3 = *(s32 *)&processor->interruptreg;
  /* Sticky trace pending bit. */
  t6 = t2 | t6;
  /* Get the trap/suspend bits */
  t4 = *(u64 *)&(processor->please_stop);
  /* Restore the frame pointer. */
  iFP = iFP - t1;
  /* Restore the control register */
  *(u32 *)&processor->control = t6;
  /* extract the argument size */
  t1 = t6 & 255;
  t3 = t3 & 1;
  t3 = t4 | t3;
  *(u64 *)&processor->stop_interpreter = t3;
  /* Restore the local pointer. */
  iLP = (t1 * 8) + iFP;

g6230:
  if (_trace) printf("g6230:\n");
  /* ARG6 = stack-cache underflow */
  arg6 = ((u64)iFP < (u64)arg6) ? 1 : 0;
  /* arg4 -2=effect -1=value 0=return 1=multiple */
  if (arg4 == 0)
    goto returnsinglereturn;
  if ((arg4 & 1) == 0)
    goto returnsingleeffect;
  *(u64 *)(iSP + 8) = arg3;
  iSP = iSP + 8;
  if ((s64)arg4 > 0)
    goto returnsinglemultiple;

returnsingleeffect:
  if (_trace) printf("returnsingleeffect:\n");

returnsingledone:
  if (_trace) printf("returnsingledone:\n");
  if (arg6 != 0)
    goto returnsingleunderflow;
  /* No prediction, validate cache */
  if (t7 == 0)
    goto interpretinstructionforbranch;
  iCP = t7;
  goto INTERPRETINSTRUCTION;

returnsinglemultiple:
  if (_trace) printf("returnsinglemultiple:\n");
  /* Multiple-value group */
  t8 = Type_Fixnum;
  t8 = t8 << 32;
  iSP = iSP + 8;
  t8 = t8 | 1;
  /* Push Fixnum */
  *(u64 *)iSP = t8;
  goto returnsingledone;

returnsinglereturn:
  if (_trace) printf("returnsinglereturn:\n");
  if (arg2 != 0)
    goto returnsingledone;
  *(u64 *)(iSP + 8) = arg3;
  iSP = iSP + 8;
  goto returnsingledone;

returnsinglecleanup:
  if (_trace) printf("returnsinglecleanup:\n");
  goto handleframecleanup;

returnsingleunderflow:
  if (_trace) printf("returnsingleunderflow:\n");
  goto stackcacheunderflowcheck;

/* end DoReturnSingle */
  /* End of Halfword operand from stack instruction - DoReturnSingle */
/* start callindirect */

  /* Fullword instruction - callindirect */
#ifdef TRACING
#endif

callindirect:
  if (_trace) printf("callindirect:\n");

callindirectprefetch:
  if (_trace) printf("callindirectprefetch:\n");
  /* Get operand */
  arg2 = (u32)arg3;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* No extra arg */
  arg3 = zero;
  /* Memory Read Internal */

g6247:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6249;

g6248:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6251;

g6258:
  t5 = arg5 - Type_CompiledFunction;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto startcallagain;
  arg5 = Type_EvenPC;
  t7 = *((s32 *)(&processor->continuation)+1);
  /* prepare to push continuation/control register */
  iSP = iSP + 16;
  t3 = *(s32 *)&processor->control;
  t6 = Type_Fixnum+0xC0;
  t8 = *(s32 *)&processor->continuation;
  t5 = (64) << 16;
  /* Set CDR code 3 */
  t7 = t7 | 192;
  /* push continuation */
  *(u32 *)(iSP + -8) = t8;
  /* write the stack cache */
  *(u32 *)(iSP + -4) = t7;
  /* Set call started bit in CR */
  t8 = t3 | t5;
  t5 = zero + 256;
  /* Push control register */
  *(u32 *)iSP = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  /* Clear the extra arg bit */
  t8 = t8 & ~t5;
  /* Save control with new state */
  *(u32 *)&processor->control = t8;
  /* End of push-frame */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)&processor->continuation = arg6;
  *((u32 *)(&processor->continuation)+1) = arg5;
  *(u64 *)&processor->continuationcp = zero;
  if (arg3 != 0)
    goto callindirectextra;
  goto cachevalid;

callindirectextra:
  if (_trace) printf("callindirectextra:\n");
  t1 = *(s32 *)&processor->control;
  t2 = zero + 256;
  /* set CDR-NEXT */
  t3 = arg3 & 63;
  /* Push the extra arg. */
  *(u32 *)(iSP + 8) = arg4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  /* Set the extra arg bit */
  t1 = t1 | t2;
  /* Save control with new state */
  *(u32 *)&processor->control = t1;
  goto cachevalid;

g6251:
  if (_trace) printf("g6251:\n");
  if ((t7 & 1) == 0)
    goto g6250;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6247;

g6250:
  if (_trace) printf("g6250:\n");

g6249:
  if (_trace) printf("g6249:\n");
  r0 = (u64)&&return0001;
  goto memoryreaddatadecode;
return0001:
  goto g6258;

/* end callindirect */
  /* End of Fullword instruction - callindirect */
/* start DoFinishCallN */

  /* Halfword 10 bit immediate instruction - DoFinishCallN */

dofinishcalln:
  if (_trace) printf("dofinishcalln:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoFinishCallNIM:
  if (_trace) printf("DoFinishCallNIM:\n");

DoFinishCallNSP:
  if (_trace) printf("DoFinishCallNSP:\n");

DoFinishCallNLP:
  if (_trace) printf("DoFinishCallNLP:\n");

DoFinishCallNFP:
  if (_trace) printf("DoFinishCallNFP:\n");
  /* arg1 has operand preloaded. */
  /* arg2 contains the 8 bit N+1 */
  /* arg1 contains the disposition (two bits) */
  arg1 = (u8)(arg3 >> ((5&7)*8));
  /* convert N to words (stacked words that is) */
  arg2 = (arg2 * 8) + zero;

finishcallmerge:
  if (_trace) printf("finishcallmerge:\n");
  arg3 = arg3 >> 7;
  /* Current stack cache limit (words) */
  t6 = *(s32 *)&processor->scovlimit;
  t3 = zero + 128;
  /* Alpha base of stack cache */
  t4 = *(u64 *)&(processor->stackcachedata);
  /* SCA of desired end of cache */
  t3 = (t3 * 8) + iSP;
  /* SCA of current end of cache */
  t4 = (t6 * 8) + t4;
  t6 = ((s64)t3 <= (s64)t4) ? 1 : 0;
  /* We're done if new SCA is within bounds */
  if (t6 == 0)
    goto g6267;
  /* 0 if not apply, 8 if apply */
  arg3 = arg3 & 8;
  /* Get the control register */
  t1 = *(s32 *)&processor->control;
  /* Compute the new LP */
  /* Assume not Apply case. */
  iLP = iSP + 8;
  /* For apply, iLP==iSP */
  iLP = iLP - arg3;
  /* Compute the new FP */
  /* extra arg bit<<3 */
  t3 = t1 >> 5;
  t2 = iSP - arg2;
  /* 8 if extra arg, 0 otherwise. */
  t3 = t3 & 8;
  /* This! is the new frame pointer! */
  t2 = t2 - t3;
  /* compute arg size */
  t4 = iLP - t2;
  /* arg size in words. */
  t4 = t4 >> 3;
  /* compute caller frame size. */
  t5 = t2 - iFP;
  /* caller frame size in words. */
  t5 = t5 >> 3;
  /* Now hack the control register! */
  /* Get value disposition into place */
  t7 = arg1 << 18;
  /* cr.caller-frame-size */
  t6 = *(u64 *)&(processor->fccrmask);
  /* Shift caller frame size into place */
  t5 = t5 << 9;
  /* Add arg size to new bits. */
  t7 = t7 | t4;
  /* Apply bit in place */
  t4 = arg3 << 14;
  /* Add frame size to new bits */
  t7 = t5 | t7;
  /* All new bits assembled! */
  t7 = t4 | t7;
  /* Set the return continuation. */
  /* Next instruction hw format */
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Mask off unwanted bits */
  t1 = t1 & t6;
  /* Get the new PC tag/data */
  t4 = *(s32 *)&processor->continuation;
  /* Add argsize, apply, disposition, caller FS */
  t1 = t1 | t7;
  t3 = *((s32 *)(&processor->continuation)+1);
  /* Update the PC */
  /* Convert PC to a real continuation. */
  t6 = t5 & 1;
  /* convert PC to a real word address. */
  t7 = t5 >> 1;
  t6 = t6 + Type_EvenPC;
  t4 = (u32)t4;
  /* Convert real continuation to PC. */
  iPC = t3 & 1;
  iPC = t4 + iPC;
  iPC = t4 + iPC;
  *(u32 *)&processor->continuation = t7;
  /* Set return address */
  *((u32 *)(&processor->continuation)+1) = t6;
  /* Update CP */
  t7 = (4096) << 16;
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t7 = t7 & t1;
  /* Shift into trace pending place */
  t7 = t7 >> 1;
  *(u64 *)&processor->continuationcp = t5;
  /* Set the cr.trace pending if appropriate. */
  t1 = t1 | t7;
  /* Set the control register */
  *(u32 *)&processor->control = t1;
  /* Install the new frame pointer */
  iFP = t2;
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
  /* Check for stack overflow */
  /* Isolate trap mode */
  t1 = t1 >> 30;
  /* Limit for emulator mode */
  t3 = *(s32 *)&processor->cslimit;
  /* Limit for extra stack and higher modes */
  t4 = *(s32 *)&processor->csextralimit;
  /* Get the right limit for the current trap mode */
  if (t1)
    t3 = t4;
  /* Might have been sign extended */
  t3 = (u32)t3;
  /* Convert stack cache address to VMA */
  t4 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t4 = iSP - t4;
  /* convert byte address to word address */
  t4 = t4 >> 3;
  /* reconstruct VMA */
  t1 = t4 + t1;
  /* Check for overflow */
  t4 = ((s64)t1 < (s64)t3) ? 1 : 0;
  /* Jump if overflow */
  if (t4 == 0)
    goto stackoverflow;
  if (arg2 != 0)
    goto interpretinstructionpredicted;
  /* Begin execution at the computed address */
  goto interpretinstructionforbranch;

g6267:
  if (_trace) printf("g6267:\n");
  arg2 = 0;
  goto stackcacheoverflowhandler;

/* end DoFinishCallN */
  /* End of Halfword operand from stack instruction - DoFinishCallN */
/* start DoEntryRestNotAccepted */

  /* Field Extraction instruction - DoEntryRestNotAccepted */

doentryrestnotaccepted:
  if (_trace) printf("doentryrestnotaccepted:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoEntryRestNotAcceptedIM:
  if (_trace) printf("DoEntryRestNotAcceptedIM:\n");

DoEntryRestNotAcceptedSP:
  if (_trace) printf("DoEntryRestNotAcceptedSP:\n");

DoEntryRestNotAcceptedLP:
  if (_trace) printf("DoEntryRestNotAcceptedLP:\n");

DoEntryRestNotAcceptedFP:
  if (_trace) printf("DoEntryRestNotAcceptedFP:\n");
  /* The control register */
  arg5 = *(s32 *)&processor->control;
  /* Pull down the number of optionals */
  arg4 = arg3 >> 18;
  /* Extract the 'ptr' field while we are waiting */
  arg1 = (u8)(arg3 >> ((5&7)*8));
  arg4 = arg4 & 255;
  /* arg1=ptr field, arg2=required, arg3=instn, arg4=optionals arg5=control-register */
  /* Get the cr.trace-pending bit */
  t2 = arg5 >> 27;
  /* The supplied args */
  t1 = arg5 & 255;
  if (t2 & 1)
    goto tracetrap;
  t3 = arg5 >> 17;
  /* Get the tag of the stack top. */
  t4 = *(s32 *)(iSP + 4);

g6278:
  if (_trace) printf("g6278:\n");
  /* J. if apply args */
  if (t3 & 1)
    goto g6276;

g6277:
  /* t2=supplied-minimum */
  t2 = t1 - arg2;
  /* B. if too few args. */
  if ((s64)t2 < 0)
    goto retryernatoofew;
  /* maximum-supplied */
  arg1 = arg4 - t1;
  /* B. if too many args. */
  if ((s64)arg1 < 0)
    goto retryernatoomany;
  /* Compute entry position and advance PC/CP accordingly. */
  /* get the next PC */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Adjust index to halfword */
  t3 = t2 << 1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* J. if index zero, no adjustment. */
  if (t2 == 0)
    goto INTERPRETINSTRUCTION;
  /* Compute the new address */
  iPC = iPC + t3;
  /* Make it an DTP-EVEN-PC */
  iPC = iPC & ~1L;
  goto interpretinstructionforjump;

applysupprna:
  if (_trace) printf("applysupprna:\n");
  arg1 = arg4 - t1;
  /* B. if too many args. */
  if ((s64)arg1 <= 0)
    goto retryernatoomany;
  goto pullapplyargs;

retryernatoomany:
  if (_trace) printf("retryernatoomany:\n");
  arg5 = 0;
  arg2 = 78;
  goto illegaloperand;

retryernatoofew:
  if (_trace) printf("retryernatoofew:\n");
  arg5 = 0;
  arg2 = 77;
  goto illegaloperand;

g6276:
  if (_trace) printf("g6276:\n");
  t4 = t4 & 63;
  t4 = t4 - Type_NIL;
  /* J. if apply args supplied not nil. */
  if (t4 != 0)
    goto applysupprna;
  /* keep just the apply bit! */
  t3 = t3 & 1;
  /* reposition the apply bit */
  t3 = t3 << 17;
  /* Pop off the null applied arg. */
  iSP = iSP - 8;
  /* Blast the apply arg bit away */
  arg5 = arg5 & ~t3;
  /* Reset the stored cr bit */
  *(u32 *)&processor->control = arg5;
  goto g6277;

/* end DoEntryRestNotAccepted */
  /* End of Halfword operand from stack instruction - DoEntryRestNotAccepted */
/* start VerifyGenericArity */


verifygenericarity:
  if (_trace) printf("verifygenericarity:\n");
  t11 = (2) << 16;
  t11 = t11 & arg2;
  /* not applying */
  if (t11 == 0)
    goto g6287;
  /* 4 - argsize */
  arg1 = zero - arg5;
  goto pullapplyargs;

g6287:
  if (_trace) printf("g6287:\n");
  arg5 = 0;
  arg2 = 77;
  goto illegaloperand;

/* end VerifyGenericArity */
/* start PullApplyArgs */


pullapplyargs:
  if (_trace) printf("pullapplyargs:\n");
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  t2 = *(s32 *)iSP;
  t1 = *(s32 *)(iSP + 4);
  t2 = (u32)t2;
  /* Strip off any CDR code bits. */
  t4 = t1 & 63;
  t5 = (t4 == Type_List) ? 1 : 0;

g6316:
  if (_trace) printf("g6316:\n");
  if (t5 == 0)
    goto g6290;
  /* Here if argument TypeList */
  /* Stack cache offset */
  t5 = t2 - arg5;
  /* In range? */
  t6 = ((u64)t5 < (u64)arg6) ? 1 : 0;
  t4 = *(u64 *)&(processor->stackcachedata);
  /* J. if not in cache */
  if (t6 == 0)
    goto g6288;
  /* reconstruct SCA */
  t4 = (t5 * 8) + t4;
  t7 = zero;
  t5 = zero + 128;
  /* Alpha base of stack cache */
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Account for what we're about to push */
  t5 = t5 + arg1;
  /* SCA of desired end of cache */
  t5 = (t5 * 8) + iSP;
  /* SCA of current end of cache */
  t6 = (arg6 * 8) + t6;
  t10 = ((s64)t5 <= (s64)t6) ? 1 : 0;
  /* We're done if new SCA is within bounds */
  if (t10 == 0)
    goto g6297;
  /* Pop Stack. */
  iSP = iSP - 8;
  goto g6296;

g6291:
  if (_trace) printf("g6291:\n");
  t9 = *(s32 *)t4;
  t8 = *(s32 *)(t4 + 4);
  t9 = (u32)t9;
  t7 = t7 + 1;
  t4 = t4 + 8;
  /* Extract CDR code. */
  t5 = t8 & 192;
  if (t5 != 0)
    goto g6299;
  /* Here if argument 0 */
  /* set CDR-NEXT */
  t5 = t8 & 63;
  *(u32 *)(iSP + 8) = t9;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t5 = (t7 == arg1) ? 1 : 0;
  if (t5 == 0)
    goto g6291;
  goto g6292;

g6299:
  if (_trace) printf("g6299:\n");
  t6 = (t5 == 64) ? 1 : 0;

g6311:
  if (_trace) printf("g6311:\n");
  if (t6 == 0)
    goto g6300;
  /* Here if argument 64 */
  /* set CDR-NEXT */
  t5 = t8 & 63;
  *(u32 *)(iSP + 8) = t9;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;

g6294:
  if (_trace) printf("g6294:\n");
  t5 = *(s32 *)&processor->control;
  /* Get current arg size. */
  t6 = t5 & 255;
  t5 = t5 & ~255L;
  t6 = t6 + t7;
  /* Update the arg size */
  t5 = t6 + t5;
  t6 = (2) << 16;
  /* turn off cr.apply */
  t5 = t5 & ~t6;
  *(u32 *)&processor->control = t5;
  iLP = (t7 * 8) + iLP;
  goto INTERPRETINSTRUCTION;

g6300:
  if (_trace) printf("g6300:\n");
  t6 = (t5 == 128) ? 1 : 0;

g6312:
  if (_trace) printf("g6312:\n");
  if (t6 == 0)
    goto g6301;
  /* Here if argument 128 */
  /* set CDR-NEXT */
  t5 = t8 & 63;
  *(u32 *)(iSP + 8) = t9;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t11 = *(s32 *)t4;
  t10 = *(s32 *)(t4 + 4);
  t11 = (u32)t11;
  /* Strip off any CDR code bits. */
  t5 = t10 & 63;
  t6 = (t5 == Type_List) ? 1 : 0;

g6307:
  if (_trace) printf("g6307:\n");
  if (t6 == 0)
    goto g6303;
  /* Here if argument TypeList */
  /* Stack cache offset */
  t5 = t11 - arg5;
  /* In range? */
  t6 = ((u64)t5 < (u64)arg6) ? 1 : 0;
  t4 = *(u64 *)&(processor->stackcachedata);
  /* J. if not in cache */
  if (t6 == 0)
    goto g6293;
  /* reconstruct SCA */
  t4 = (t5 * 8) + t4;
  goto g6296;

g6303:
  if (_trace) printf("g6303:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;

g6308:
  if (_trace) printf("g6308:\n");
  if (t6 == 0)
    goto g6304;
  /* Here if argument TypeNIL */
  goto g6294;

g6304:
  if (_trace) printf("g6304:\n");
  /* Here for all other cases */

g6293:
  if (_trace) printf("g6293:\n");
  /* set CDR-NEXT */
  t5 = t10 & 63;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto g6295;

g6302:
  if (_trace) printf("g6302:\n");

g6301:
  if (_trace) printf("g6301:\n");
  /* Here for all other cases */
  t7 = t7 - 1;
  t4 = t4 - 8;
  goto g6292;

g6298:
  if (_trace) printf("g6298:\n");

g6296:
  t5 = (t7 == arg1) ? 1 : 0;
  if (t5 == 0)
    goto g6291;

g6292:
  if (_trace) printf("g6292:\n");
  /* Here if count=n, or bad cdr */
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);
  /* stack cache base relative offset */
  t5 = t4 - t5;
  /* convert byte address to word address */
  t5 = t5 >> 3;
  /* reconstruct VMA */
  t9 = t5 + arg5;
  t5 = Type_List;
  *(u32 *)(iSP + 8) = t9;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;

g6295:
  if (_trace) printf("g6295:\n");
  t5 = *(s32 *)&processor->control;
  /* Get current arg size. */
  t6 = t5 & 255;
  t5 = t5 & ~255L;
  t6 = t6 + t7;
  /* Update the arg size */
  t5 = t6 + t5;
  *(u32 *)&processor->control = t5;
  iLP = (t7 * 8) + iLP;
  arg1 = arg1 - t7;
  if ((s64)arg1 <= 0)
    goto INTERPRETINSTRUCTION;
  goto pullapplyargsslowly;

g6290:
  if (_trace) printf("g6290:\n");
  t5 = (t4 == Type_NIL) ? 1 : 0;

g6317:
  if (_trace) printf("g6317:\n");
  if (t5 == 0)
    goto g6313;
  /* Here if argument TypeNIL */
  /* Get the control register */
  t6 = *(s32 *)&processor->control;
  t7 = (2) << 16;
  /* Discard that silly nil */
  iSP = iSP - 8;
  /* Blast away the apply arg bit. */
  t6 = t6 & ~t7;
  *(u32 *)&processor->control = t6;
  goto INTERPRETINSTRUCTION;

g6313:
  if (_trace) printf("g6313:\n");
  /* Here for all other cases */
  /* Pull apply args trap needs nargs in ARG1 */
  arg1 = arg1;
  goto pullapplyargstrap;

g6288:
  if (_trace) printf("g6288:\n");
  arg1 = arg1;
  goto pullapplyargsslowly;

g6289:
  if (_trace) printf("g6289:\n");

g6297:
  if (_trace) printf("g6297:\n");
  arg2 = arg1;
  goto stackcacheoverflowhandler;

/* end PullApplyArgs */
/* start valuecell */

  /* Fullword instruction - valuecell */
#ifdef TRACING
#endif

valuecell:
  if (_trace) printf("valuecell:\n");
  /* Get address */
  arg2 = (u32)arg3;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g6318:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6320;

g6319:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6322;

g6329:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* set CDR-NEXT */
  t3 = arg5 & 63;
  /* Push the result */
  *(u32 *)(iSP + 8) = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  goto cachevalid;

g6322:
  if (_trace) printf("g6322:\n");
  if ((t7 & 1) == 0)
    goto g6321;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6318;

g6321:
  if (_trace) printf("g6321:\n");

g6320:
  if (_trace) printf("g6320:\n");
  r0 = (u64)&&return0002;
  goto memoryreaddatadecode;
return0002:
  goto g6329;

/* end valuecell */
  /* End of Fullword instruction - valuecell */
/* start pushconstantvalue */

  /* Fullword instruction - pushconstantvalue */
#ifdef TRACING
#endif

pushconstantvalue:
  if (_trace) printf("pushconstantvalue:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u64 *)(iSP + 8) = arg3;
  iSP = iSP + 8;
  goto cachevalid;

/* end pushconstantvalue */
  /* End of Fullword instruction - pushconstantvalue */
/* start DoZerop */

  /* Halfword operand from stack instruction - DoZerop */
  /* arg2 has the preloaded 8 bit operand. */

dozerop:
  if (_trace) printf("dozerop:\n");
#ifdef TRACING
#endif

DoZeropSP:
  if (_trace) printf("DoZeropSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindozerop;
#endif

DoZeropLP:
  if (_trace) printf("DoZeropLP:\n");
#ifdef TRACING
  goto begindozerop;
#endif

DoZeropFP:
  if (_trace) printf("DoZeropFP:\n");

begindozerop:
  if (_trace) printf("begindozerop:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->niladdress);
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t1 = *(s32 *)(arg1 + 4);
  t12 = *(u64 *)&(processor->taddress);
  t2 = *(s32 *)arg1;
  LDS(1, f1, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t4 = t1 & 63;
  t5 = (t4 == Type_Fixnum) ? 1 : 0;

g6335:
  if (_trace) printf("g6335:\n");
  if (t5 == 0)
    goto g6331;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* T if predicate succeeds */
  if (t2 == 0)
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;
  iSP = iSP + 8;
  goto cachevalid;

g6331:
  if (_trace) printf("g6331:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;

g6336:
  if (_trace) printf("g6336:\n");
  if (t5 == 0)
    goto g6332;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  if (FLTU64(1, f1) == 0.0)
    goto cachevalid;
  /* Didn't branch, answer is NIL */
  *(u64 *)iSP = t11;
  goto cachevalid;

g6332:
  if (_trace) printf("g6332:\n");
  /* Here for all other cases */
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto unarynumericexception;

g6330:
  if (_trace) printf("g6330:\n");
#ifdef TRACING
  goto DoZeropIM;
#endif

DoZeropIM:
  if (_trace) printf("DoZeropIM:\n");
  t2 = *(u64 *)&(processor->taddress);
  iSP = iSP + 8;
  t1 = *(u64 *)&(processor->niladdress);
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  if (arg2 == 0)
    t1 = t2;
  /* yes Virginia, we dual issue with above yahoo */
  *(u64 *)iSP = t1;
  goto cachevalid;

/* end DoZerop */
  /* End of Halfword operand from stack instruction - DoZerop */
/* start DoSetSpToAddress */

  /* Halfword operand from stack instruction - DoSetSpToAddress */
  /* arg2 has the preloaded 8 bit operand. */

dosetsptoaddress:
  if (_trace) printf("dosetsptoaddress:\n");
#ifdef TRACING
#endif

DoSetSpToAddressSP:
  if (_trace) printf("DoSetSpToAddressSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindosetsptoaddress;
#endif

DoSetSpToAddressLP:
  if (_trace) printf("DoSetSpToAddressLP:\n");
#ifdef TRACING
  goto begindosetsptoaddress;
#endif

DoSetSpToAddressFP:
  if (_trace) printf("DoSetSpToAddressFP:\n");

begindosetsptoaddress:
  if (_trace) printf("begindosetsptoaddress:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Set iSP=address of operand */
  iSP = arg1;
  goto cachevalid;
#ifdef TRACING
#endif

DoSetSpToAddressIM:
  goto doistageerror;

/* end DoSetSpToAddress */
  /* End of Halfword operand from stack instruction - DoSetSpToAddress */
/* start DoEq */

  /* Halfword operand from stack instruction - DoEq */
  /* arg2 has the preloaded 8 bit operand. */

doeq:
  if (_trace) printf("doeq:\n");
#ifdef TRACING
#endif

DoEqSP:
  if (_trace) printf("DoEqSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoeq;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoeq;
#endif

DoEqLP:
  if (_trace) printf("DoEqLP:\n");
#ifdef TRACING
  goto begindoeq;
#endif

DoEqFP:
  if (_trace) printf("DoEqFP:\n");

begindoeq:
  if (_trace) printf("begindoeq:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->niladdress);
  arg3 = arg3 >> 12;
  t12 = *(u64 *)&(processor->taddress);
  /* load op2 */
  arg1 = *(u64 *)arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* 1 if no-pop, 0 if pop */
  arg3 = arg3 & 1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* compare tag and data */
  t3 = arg6 ^ arg1;
  /* shift off the cdr code */
  t3 = t3 << 26;
  /* Either a stack-push or a stack-write */
  iSP = (arg3 * 8) + iSP;
  /* pick up T or NIL */
  if (t3 == 0)
    t11 = t12;
  *(u64 *)iSP = t11;
  goto cachevalid;

/* end DoEq */
  /* End of Halfword operand from stack instruction - DoEq */
/* start DoAref1 */

  /* Halfword operand from stack instruction - DoAref1 */
  /* arg2 has the preloaded 8 bit operand. */

doaref1:
  if (_trace) printf("doaref1:\n");
#ifdef TRACING
#endif

DoAref1SP:
  if (_trace) printf("DoAref1SP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto headdoaref1;
  /* SP-pop mode, TOS->arg1 */
  arg1 = arg6;
  /* Reload TOS */
  arg6 = *(u64 *)arg4;
  /* Adjust SP */
  iSP = arg4;
  goto begindoaref1;
#ifdef TRACING
  goto headdoaref1;
#endif

DoAref1LP:
  if (_trace) printf("DoAref1LP:\n");
#ifdef TRACING
  goto headdoaref1;
#endif

DoAref1FP:
  if (_trace) printf("DoAref1FP:\n");

headdoaref1:
  if (_trace) printf("headdoaref1:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoaref1:
  if (_trace) printf("begindoaref1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg3 = (u32)(arg6 >> ((4&7)*8));
  /* Get the array tag/data */
  arg4 = (u32)arg6;
  /* (sign-extended, for fast bounds check) Index Data */
  arg2 = (s32)arg1 + (s32)0;
  t8 = zero + AutoArrayRegMask;
  t8 = arg4 & t8;
  /* Index Tag */
  arg1 = arg1 >> 32;
  t7 = (u64)&processor->ac0array;
  /* This is the address if the array register block. */
  t7 = t7 + t8;
  t1 = arg1 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto aref1illegal;

aref1merge:
  if (_trace) printf("aref1merge:\n");
  if (arg4 == 0)
    goto aref1regset;
  /* Cached array object. */
  t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array);
  t1 = arg3 - Type_Array;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto reallyaref1exc;
  /* t8==1 iff cached array is ours. */
  t8 = (arg4 == t8) ? 1 : 0;
  /* Go and setup the array register. */
  if (t8 == 0)
    goto aref1regset;
#ifdef SLOWARRAYS
  goto aref1regset;
#endif
  arg6 = *(u64 *)&(((ARRAYCACHEP)t7)->arword);
  /* high order bits all zero */
  t9 = *(u64 *)&(((ARRAYCACHEP)t7)->locat);
  /* high order bits all zero */
  t3 = *(u64 *)&(((ARRAYCACHEP)t7)->length);
  t5 = arg6 << 42;
  t4 = *(u64 *)&(processor->areventcount);
  t5 = t5 >> 42;
  t2 = ((u64)arg2 < (u64)t3) ? 1 : 0;
  t6 = t4 - t5;
  /* J. if event count ticked. */
  if (t6 != 0)
    goto aref1regset;
  if (t2 == 0)
    goto aref1bounds;
  arg5 = arg6 >> (Array_RegisterBytePackingPos & 63);
  arg4 = arg6 >> (Array_RegisterByteOffsetPos & 63);
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg5 = arg5 & Array_RegisterBytePackingMask;
  arg6 = t8 & Array_RegisterElementTypeMask;

aref1restart:
  if (_trace) printf("aref1restart:\n");
  if (arg5 != 0)
    goto g6345;
  t1 = t9 + arg2;

g6346:
  if (_trace) printf("g6346:\n");
  /* Memory Read Internal */

g6353:
  /* Base of stack cache */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t5 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;
  t9 = (t5 * 4);
  arg3 = LDQ_U(t5);
  /* Stack cache offset */
  t2 = t1 - t2;
  t6 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;
  t9 = *(s32 *)t9;
  arg3 = (u8)(arg3 >> ((t5&7)*8));
  if (t3 != 0)
    goto g6355;

g6354:
  t5 = zero + 240;
  t6 = t6 >> (arg3 & 63);
  t5 = t5 >> (arg3 & 63);
  t9 = (u32)t9;
  if (t6 & 1)
    goto g6357;

g6364:
  if (arg5 != 0)
    goto g6347;

g6348:
  if (_trace) printf("g6348:\n");
  r31 = r31 | r31;
  t1 = arg6 - 2;
  if ((s64)t1 <= 0)
    goto g6349;
  /* TagType. */
  arg3 = arg3 & 63;

g6350:
  if (_trace) printf("g6350:\n");
  *(u32 *)(iSP + 4) = arg3;
  t5 = (arg5 == 0) ? 1 : 0;
  if (t5 == 0)
    goto case_others_7;

case_0_1:
  if (_trace) printf("case_0_1:\n");
  r31 = r31 | r31;
  if (t1 == 0)
    goto g6351;
  *(u32 *)iSP = t9;
  goto NEXTINSTRUCTION;

case_2_2:
  if (_trace) printf("case_2_2:\n");
  /* AREF1-8B */
  r31 = r31 | r31;
  t5 = arg2 & 3;
  t6 = (u8)(t9 >> ((t5&7)*8));
  if (t1 == 0)
    goto g6351;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;

case_3_3:
  if (_trace) printf("case_3_3:\n");
  /* AREF1-4B */
  r31 = r31 | r31;
  /* byte-index */
  t5 = arg2 & 7;
  /* byte-position */
  t5 = t5 << 2;
  /* byte in position */
  t6 = t9 >> (t5 & 63);
  /* byte masked */
  t6 = t6 & 15;
  if (t1 == 0)
    goto g6351;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;

case_5_4:
  if (_trace) printf("case_5_4:\n");
  /* AREF1-1B */
  r31 = r31 | r31;
  /* byte-index */
  t5 = arg2 & 31;
  r31 = r31 | r31;
  /* byte in position */
  t6 = t9 >> (t5 & 63);
  /* byte masked */
  t6 = t6 & 1;
  if (t1 == 0)
    goto g6351;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;

case_1_5:
  if (_trace) printf("case_1_5:\n");
  /* AREF1-16B */
  t5 = arg2 & 1;
  /* Bletch, it's a byte ref */
  t5 = t5 + t5;
  t6 = (u16)(t9 >> ((t5&7)*8));
  if (t1 == 0)
    goto g6351;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;

case_others_7:
  if (_trace) printf("case_others_7:\n");
  r31 = r31 | r31;
  t5 = (arg5 == 2) ? 1 : 0;
  t6 = (arg5 == 3) ? 1 : 0;
  if (t5 != 0)
    goto case_2_2;
  t5 = (arg5 == 5) ? 1 : 0;
  if (t6 != 0)
    goto case_3_3;
  t6 = (arg5 == 1) ? 1 : 0;
  if (t5 != 0)
    goto case_5_4;
  if (t6 != 0)
    goto case_1_5;

case_4_6:
  if (_trace) printf("case_4_6:\n");
  /* AREF1-2B */
  r31 = r31 | r31;
  /* byte-index */
  t5 = arg2 & 15;
  /* byte-position */
  t5 = t5 << 1;
  /* byte in position */
  t6 = t9 >> (t5 & 63);
  /* byte masked */
  t6 = t6 & 3;
  if (t1 == 0)
    goto g6351;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;

g6345:
  if (_trace) printf("g6345:\n");
  arg2 = arg4 + arg2;
  /* Convert byte index to word index */
  t1 = arg2 >> (arg5 & 63);
  /* Address of word containing byte */
  t1 = t1 + t9;
  goto g6346;

g6347:
  if (_trace) printf("g6347:\n");
  t1 = arg3 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto g6352;
  goto g6348;

g6349:
  if (_trace) printf("g6349:\n");
  arg3 = Type_Character;
  if (arg6 & 1)
    goto g6350;
  arg3 = Type_Fixnum;
  if (arg6 == 0)
    goto g6350;
  t2 = *(u64 *)&(processor->niladdress);
  t3 = *(u64 *)&(processor->taddress);
  goto g6350;

g6351:
  if (_trace) printf("g6351:\n");
  if (t6)
    t2 = t3;
  *(u64 *)iSP = t2;
  goto NEXTINSTRUCTION;

g6352:
  if (_trace) printf("g6352:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;
#ifdef TRACING
  goto DoAref1IM;
#endif

DoAref1IM:
  if (_trace) printf("DoAref1IM:\n");
  t8 = zero + AutoArrayRegMask;
  /* Get the array tag/data */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  t7 = (u64)&processor->ac0array;
  t8 = arg4 & t8;
  /* This is the address of the array register block. */
  t7 = t7 + t8;
  goto aref1merge;

g6355:
  if (_trace) printf("g6355:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t2 = (t2 * 8) + t3;
  t9 = *(s32 *)t2;
  /* Read from stack cache */
  arg3 = *(s32 *)(t2 + 4);
  goto g6354;

g6357:
  if (_trace) printf("g6357:\n");
  if ((t5 & 1) == 0)
    goto g6356;
  /* Do the indirect thing */
  t1 = (u32)t9;
  goto g6353;

g6356:
  if (_trace) printf("g6356:\n");
  /* Load the memory action table for cycle */
  t6 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t5 = arg3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t5 = (t5 * 4) + t6;
  /* Get the memory action */
  t6 = *(s32 *)t5;

g6361:
  if (_trace) printf("g6361:\n");
  t5 = t6 & MemoryActionTransform;
  if (t5 == 0)
    goto g6360;
  arg3 = arg3 & ~63L;
  arg3 = arg3 | Type_ExternalValueCellPointer;
  goto g6364;
#ifndef MINIMA

g6360:
#endif
#ifdef MINIMA

g6360:
  if (_trace) printf("g6360:\n");
  t5 = t6 & MemoryActionBinding;
  t3 = *(u64 *)&(processor->dbcmask);
  if (t5 == 0)
    goto g6359;
  t2 = t1 << 1;
  t5 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t2 = t2 & t3;
  t3 = 1;
  t3 = t3 << (ivorymemorydata & 63);
  t2 = (s32)t2 + (s32)t5;
  /* Clear sign-extension */
  t2 = (u32)t2;
  t3 = (t2 * 4) + t3;
  /* Fetch the key */
  t2 = *(s32 *)t3;
  /* Fetch value */
  t9 = *(s32 *)(t3 + 4);
  /* Compare */
  t5 = (s32)t1 - (s32)t2;
  /* Trap on miss */
  if (t5 != 0)
    goto g6363;
  /* Extract the pointer, and indirect */
  t1 = (u32)t9;
  goto g6353;

g6363:
  if (_trace) printf("g6363:\n");
  goto dbcachemisstrap;
#endif

g6359:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 0;
  goto performmemoryaction;

/* end DoAref1 */
  /* End of Halfword operand from stack instruction - DoAref1 */
/* start DoTypeMember */

  /* Halfword 10 bit immediate instruction - DoTypeMember */

dotypemember:
  if (_trace) printf("dotypemember:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoTypeMemberIM:
  if (_trace) printf("DoTypeMemberIM:\n");

DoTypeMemberSP:
  if (_trace) printf("DoTypeMemberSP:\n");

DoTypeMemberLP:
  if (_trace) printf("DoTypeMemberLP:\n");

DoTypeMemberFP:
  if (_trace) printf("DoTypeMemberFP:\n");
  /* arg1 has operand preloaded. */
  /* Position the opcode */
  t6 = arg3 >> 6;
  t4 = *(u64 *)&(processor->taddress);
  /* get op1's tag */
  arg4 = *(s32 *)(iSP + 4);
  t1 = 1;
  t5 = *(u64 *)&(processor->niladdress);
  /* Get pop-bit while stalled */
  t7 = arg3 >> 12;
  /* Get field-number*4 from the opcode */
  arg1 = t6 & 60;
  /* TagType. */
  /* Strip off CDR code. */
  arg4 = arg4 & 63;
  /* T1 is type type code bit position. */
  t1 = t1 << (arg4 & 63);
  /* Pop bit */
  t7 = t7 & 1;
  /* t2 is the mask. */
  t2 = arg2 << (arg1 & 63);
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = (t7 * 8) + iSP;
  /* t3 is the result. */
  t3 = t2 & t1;

g6373:
  if (_trace) printf("g6373:\n");
  if (t3)
    t5 = t4;
  *(u64 *)iSP = t5;
  goto cachevalid;

/* end DoTypeMember */
  /* End of Halfword operand from stack instruction - DoTypeMember */
/* start DoPointerPlus */

  /* Halfword operand from stack instruction - DoPointerPlus */
  /* arg2 has the preloaded 8 bit operand. */

dopointerplus:
  if (_trace) printf("dopointerplus:\n");
#ifdef TRACING
#endif

DoPointerPlusSP:
  if (_trace) printf("DoPointerPlusSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindopointerplus;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindopointerplus;
#endif

DoPointerPlusLP:
  if (_trace) printf("DoPointerPlusLP:\n");
#ifdef TRACING
  goto begindopointerplus;
#endif

DoPointerPlusFP:
  if (_trace) printf("DoPointerPlusFP:\n");

begindopointerplus:
  if (_trace) printf("begindopointerplus:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Get the data of op2 */
  t2 = *(s32 *)arg1;
  /* (%32-bit-plus (data arg1) (data arg2)) */
  t3 = (s32)arg6 + (s32)t2;
  /* Put result back on the stack */
  *(u32 *)iSP = t3;
  goto cachevalid;
#ifdef TRACING
  goto DoPointerPlusIM;
#endif

DoPointerPlusIM:
  if (_trace) printf("DoPointerPlusIM:\n");
  t2 = arg2 << 56;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t2 = (s64)t2 >> 56;

g6374:
  if (_trace) printf("g6374:\n");
  /* (%32-bit-plus (data arg1) (data arg2)) */
  t3 = (s32)arg6 + (s32)t2;
  /* Put result back on the stack */
  *(u32 *)iSP = t3;
  goto cachevalid;

/* end DoPointerPlus */
  /* End of Halfword operand from stack instruction - DoPointerPlus */
/* start DoLdb */

  /* Field Extraction instruction - DoLdb */

doldb:
  if (_trace) printf("doldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoLdbIM:
  if (_trace) printf("DoLdbIM:\n");

DoLdbSP:
  if (_trace) printf("DoLdbSP:\n");

DoLdbLP:
  if (_trace) printf("DoLdbLP:\n");

DoLdbFP:
  if (_trace) printf("DoLdbFP:\n");
  /* Shift the 'size-1' bits into place */
  arg1 = arg3 >> 37;
  /* mask out the unwanted bits in arg2 */
  arg2 = arg2 & 31;
  /* mask out the unwanted bits in arg1 */
  arg1 = arg1 & 31;
  /* arg1 has size-1, arg2 has position. */
  arg3 = (u32)(arg6 >> ((4&7)*8));
  /* get ARG1 tag/data */
  arg4 = (u32)arg6;
  /* TagType. */
  t8 = arg3 & 63;
  t9 = t8 - Type_Fixnum;
  /* Shift ARG1 left to get new high bits */
  t3 = arg4 << (arg2 & 63);
  /* Not a fixnum */
  if (t9 != 0)
    goto ldbexception;
  t7 = zero + -2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Get new low bits */
  t6 = (u32)(t3 >> ((4&7)*8));
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Unmask */
  t7 = t7 << (arg1 & 63);
  /* Glue two parts of shifted operand together */
  t3 = t3 | t6;
  /* T8 is TypeFixnum from above */
  *(u32 *)(iSP + 4) = t8;
  /* T3= masked value. */
  t3 = t3 & ~t7;
  *(u32 *)iSP = t3;
  goto cachevalid;

/* end DoLdb */
  /* End of Halfword operand from stack instruction - DoLdb */
/* start DoSetSpToAddressSaveTos */

  /* Halfword operand from stack instruction - DoSetSpToAddressSaveTos */
  /* arg2 has the preloaded 8 bit operand. */

dosetsptoaddresssavetos:
  if (_trace) printf("dosetsptoaddresssavetos:\n");
#ifdef TRACING
#endif

DoSetSpToAddressSaveTosSP:
  if (_trace) printf("DoSetSpToAddressSaveTosSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindosetsptoaddresssavetos;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindosetsptoaddresssavetos;
#endif

DoSetSpToAddressSaveTosLP:
  if (_trace) printf("DoSetSpToAddressSaveTosLP:\n");
#ifdef TRACING
  goto begindosetsptoaddresssavetos;
#endif

DoSetSpToAddressSaveTosFP:
  if (_trace) printf("DoSetSpToAddressSaveTosFP:\n");

begindosetsptoaddresssavetos:
  if (_trace) printf("begindosetsptoaddresssavetos:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Set the stack top as specified. */
  iSP = arg1;
  /* Restore the TOS. */
  *(u64 *)arg1 = arg6;
  goto cachevalid;
#ifdef TRACING
#endif

DoSetSpToAddressSaveTosIM:
  goto doistageerror;

/* end DoSetSpToAddressSaveTos */
  /* End of Halfword operand from stack instruction - DoSetSpToAddressSaveTos */
/* start DoPop */

  /* Halfword operand from stack instruction - DoPop */
  /* arg2 has the preloaded 8 bit operand. */

dopop:
  if (_trace) printf("dopop:\n");
#ifdef TRACING
#endif

DoPopSP:
  if (_trace) printf("DoPopSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindopop;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindopop;
#endif

DoPopLP:
  if (_trace) printf("DoPopLP:\n");
#ifdef TRACING
  goto begindopop;
#endif

DoPopFP:
  if (_trace) printf("DoPopFP:\n");

begindopop:
  if (_trace) printf("begindopop:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Pop Stack. */
  iSP = iSP - 8;
  /* Store all 40 bits on stack */
  *(u64 *)arg1 = arg6;
  goto cachevalid;
#ifdef TRACING
#endif

DoPopIM:
  goto doistageerror;

/* end DoPop */
  /* End of Halfword operand from stack instruction - DoPop */
/* start DoMovem */

  /* Halfword operand from stack instruction - DoMovem */
  /* arg2 has the preloaded 8 bit operand. */

domovem:
  if (_trace) printf("domovem:\n");
#ifdef TRACING
#endif

DoMovemSP:
  if (_trace) printf("DoMovemSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomovem;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomovem;
#endif

DoMovemLP:
  if (_trace) printf("DoMovemLP:\n");
#ifdef TRACING
  goto begindomovem;
#endif

DoMovemFP:
  if (_trace) printf("DoMovemFP:\n");

begindomovem:
  if (_trace) printf("begindomovem:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Store all 40 bits of TOS on stack */
  *(u64 *)arg1 = arg6;
  goto cachevalid;
#ifdef TRACING
#endif

DoMovemIM:
  goto doistageerror;

/* end DoMovem */
  /* End of Halfword operand from stack instruction - DoMovem */
/* start DoPushAddress */

  /* Halfword operand from stack instruction - DoPushAddress */
  /* arg2 has the preloaded 8 bit operand. */

dopushaddress:
  if (_trace) printf("dopushaddress:\n");
#ifdef TRACING
#endif

DoPushAddressSP:
  if (_trace) printf("DoPushAddressSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindopushaddress;
#endif

DoPushAddressLP:
  if (_trace) printf("DoPushAddressLP:\n");
#ifdef TRACING
  goto begindopushaddress;
#endif

DoPushAddressFP:
  if (_trace) printf("DoPushAddressFP:\n");

begindopushaddress:
  if (_trace) printf("begindopushaddress:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = arg1 - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t1 = t2 + t1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t3 = Type_Locative;
  *(u32 *)(iSP + 8) = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  goto cachevalid;
#ifdef TRACING
#endif

DoPushAddressIM:
  goto doistageerror;

/* end DoPushAddress */
  /* End of Halfword operand from stack instruction - DoPushAddress */
/* start DoMemoryRead */

  /* Halfword 10 bit immediate instruction - DoMemoryRead */

domemoryread:
  if (_trace) printf("domemoryread:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMemoryReadIM:
  if (_trace) printf("DoMemoryReadIM:\n");

DoMemoryReadSP:
  if (_trace) printf("DoMemoryReadSP:\n");

DoMemoryReadLP:
  if (_trace) printf("DoMemoryReadLP:\n");

DoMemoryReadFP:
  if (_trace) printf("DoMemoryReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  /* Low bit clear if memory-read, set if memory-read-address */
  t1 = arg3 >> 10;
  /* T2 = fixnum check */
  t2 = arg1 & 32;
  /* T3 = reset CDR code */
  t3 = arg1 & 16;
  /* arg3 = cycle type */
  arg3 = arg1 >> 6;
  arg1 = (u32)(arg6 >> ((4&7)*8));
  /* Get tag/data */
  arg2 = (u32)arg6;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g6391:
  t7 = arg2 + ivory;
  /* Cycle-number -> table offset */
  t8 = (arg3 * 4);
  arg5 = LDQ_U(t7);
  t8 = (t8 * 4) + ivory;
  arg6 = (t7 * 4);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6393;

g6392:
  t8 = t8 >> (arg5 & 63);
  if (t8 & 1)
    goto g6395;

g6402:
  /* J. if no check for fixnum. */
  if (t2 == 0)
    goto mrdataok;
  t5 = arg5 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto mrnotfixnum;

mrdataok:
  if (_trace) printf("mrdataok:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Get original tag if memory-read-address */
  if (t1 & 1)
   arg5 = arg1;
  /* J. if no reset CDR code */
  if (t3 == 0)
    goto mrcdrunch;
  /* TagType. */
  arg5 = arg5 & 63;

mrcdrunch:
  if (_trace) printf("mrcdrunch:\n");
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Get forwarded address if memory-read-address */
  if (t1 & 1)
   arg6 = arg2;
  *(u32 *)iSP = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = arg5;
  goto cachevalid;

mrnotfixnum:
  if (_trace) printf("mrnotfixnum:\n");
  arg5 = 0;
  arg2 = 5;
  goto illegaloperand;

g6395:
  if (_trace) printf("g6395:\n");

g6393:
  if (_trace) printf("g6393:\n");
  r0 = (u64)&&return0003;
  goto memoryreadgeneraldecode;
return0003:
  goto g6402;

/* end DoMemoryRead */
  /* End of Halfword operand from stack instruction - DoMemoryRead */
/* start DoBranch */

  /* Halfword 10 bit immediate instruction - DoBranch */

dobranch:
  if (_trace) printf("dobranch:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchIM:
  if (_trace) printf("DoBranchIM:\n");

DoBranchSP:
  if (_trace) printf("DoBranchSP:\n");

DoBranchLP:
  if (_trace) printf("DoBranchLP:\n");

DoBranchFP:
  if (_trace) printf("DoBranchFP:\n");
  arg1 = (s64)arg3 >> 48;
  /* arg1 has signed operand preloaded. */
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranch */
  /* End of Halfword operand from stack instruction - DoBranch */
/* start DoGenericDispatch */

  /* Halfword operand from stack instruction - DoGenericDispatch */
  /* arg2 has the preloaded 8 bit operand. */

dogenericdispatch:
  if (_trace) printf("dogenericdispatch:\n");
#ifdef TRACING
#endif

DoGenericDispatchSP:
  if (_trace) printf("DoGenericDispatchSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindogenericdispatch;
#endif

DoGenericDispatchLP:
  if (_trace) printf("DoGenericDispatchLP:\n");
#ifdef TRACING
  goto begindogenericdispatch;
#endif

DoGenericDispatchFP:
  if (_trace) printf("DoGenericDispatchFP:\n");

begindogenericdispatch:
  if (_trace) printf("begindogenericdispatch:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  arg2 = *(s32 *)&processor->control;
  /* get generic tag and data */
  arg1 = *(s32 *)(iFP + 20);
  t1 = *(s32 *)(iFP + 16);
  /* get number of arguments */
  arg5 = arg2 & 255;
  /* get instance tag and data */
  arg3 = *(s32 *)(iFP + 28);
  arg4 = *(s32 *)(iFP + 24);
  /* done if 2 or more arguments (plus 2 extra words) */
  arg5 = arg5 - 4;
  if ((s64)arg5 < 0)
    goto verifygenericarity;
  t1 = (u32)t1;
  arg4 = (u32)arg4;
  r0 = (u64)&&return0004;
  goto lookuphandler;
return0004:
  t3 = t4 - Type_EvenPC;
  /* Strip CDR code, low bits */
  t3 = t3 & 62;
  if (t3 != 0)
    goto g6404;
  /* Strip CDR code */
  t3 = t6 & 63;
  t3 = t3 - Type_NIL;
  if (t3 == 0)
    goto g6403;
  *(u32 *)(iFP + 16) = t7;
  /* write the stack cache */
  *(u32 *)(iFP + 20) = t6;

g6403:
  if (_trace) printf("g6403:\n");
  /* Convert real continuation to PC. */
  iPC = t4 & 1;
  iPC = t9 + iPC;
  iPC = t9 + iPC;
  goto interpretinstructionforjump;

g6404:
  if (_trace) printf("g6404:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t3 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = iSP - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t3 = t2 + t3;
  arg5 = t3;
  arg2 = 37;
  goto illegaloperand;
#ifdef TRACING
#endif

DoGenericDispatchIM:
  goto doistageerror;

/* end DoGenericDispatch */
  /* End of Halfword operand from stack instruction - DoGenericDispatch */
/* start LookupHandler */


lookuphandler:
  if (_trace) printf("lookuphandler:\n");
  sp = sp + -8;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  t5 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto g6408;
  /* Don't clobber instance if it's forwarded */
  arg2 = arg4;
  /* Memory Read Internal */

g6409:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6411;

g6410:
  t7 = zero + 64;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6413;

g6418:

g6407:
  if (_trace) printf("g6407:\n");
  arg2 = arg6;
  /* Memory Read Internal */

g6419:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6421;

g6420:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6423;

g6430:
  t2 = arg6;
  t5 = arg5 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g6405;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

g6431:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6433;

g6432:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6435;

g6442:
  t3 = arg6;
  t5 = arg5 - Type_Locative;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g6406;
  arg2 = t2 & t1;
  t5 = arg2 << 1;
  /* (* (logand mask data) 3) */
  arg4 = arg2 + t5;
  /* TagType. */
  arg1 = arg1 & 63;

g6444:
  if (_trace) printf("g6444:\n");
  arg2 = t3 + arg4;
  arg4 = arg4 + 3;
  /* Read key */
  /* Memory Read Internal */

g6445:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6447;

g6446:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6449;

g6456:
  /* TagType. */
  arg5 = arg5 & 63;
  t5 = (arg5 == Type_NIL) ? 1 : 0;
  if (t5 != 0)
    goto g6443;
  t5 = (arg1 == arg5) ? 1 : 0;
  if (t5 == 0)
    goto g6444;
  t5 = (s32)t1 - (s32)arg6;
  if (t5 != 0)
    goto g6444;

g6443:
  if (_trace) printf("g6443:\n");
  /* Read method */
  arg2 = arg2 + 1;
  /* Memory Read Internal */

g6457:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6459;

g6458:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6461;

g6468:
  t4 = arg5;
  arg3 = arg6;
  /* Read parameter */
  arg2 = arg2 + 1;
  /* Memory Read Internal */

g6469:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6471;

g6470:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6473;

g6480:
  t6 = arg5;
  t7 = arg6;
  t9 = arg3;
  sp = sp + 8;
  goto *r0; /* ret */

g6473:
  if (_trace) printf("g6473:\n");
  if ((t7 & 1) == 0)
    goto g6472;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6469;

g6472:
  if (_trace) printf("g6472:\n");

g6471:
  if (_trace) printf("g6471:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0005;
  goto memoryreaddatadecode;
return0005:
  r0 = *(u64 *)sp;
  goto g6480;

g6461:
  if (_trace) printf("g6461:\n");
  if ((t7 & 1) == 0)
    goto g6460;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6457;

g6460:
  if (_trace) printf("g6460:\n");

g6459:
  if (_trace) printf("g6459:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0006;
  goto memoryreaddatadecode;
return0006:
  r0 = *(u64 *)sp;
  goto g6468;

g6449:
  if (_trace) printf("g6449:\n");
  if ((t7 & 1) == 0)
    goto g6448;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6445;

g6448:
  if (_trace) printf("g6448:\n");

g6447:
  if (_trace) printf("g6447:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0007;
  goto memoryreaddatadecode;
return0007:
  r0 = *(u64 *)sp;
  goto g6456;

g6435:
  if (_trace) printf("g6435:\n");
  if ((t7 & 1) == 0)
    goto g6434;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6431;

g6434:
  if (_trace) printf("g6434:\n");

g6433:
  if (_trace) printf("g6433:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0008;
  goto memoryreaddatadecode;
return0008:
  r0 = *(u64 *)sp;
  goto g6442;

g6423:
  if (_trace) printf("g6423:\n");
  if ((t7 & 1) == 0)
    goto g6422;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6419;

g6422:
  if (_trace) printf("g6422:\n");

g6421:
  if (_trace) printf("g6421:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0009;
  goto memoryreaddatadecode;
return0009:
  r0 = *(u64 *)sp;
  goto g6430;

g6413:
  if (_trace) printf("g6413:\n");
  if ((t7 & 1) == 0)
    goto g6412;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6409;

g6412:
  if (_trace) printf("g6412:\n");

g6411:
  if (_trace) printf("g6411:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0010;
  goto memoryreadheaderdecode;
return0010:
  r0 = *(u64 *)sp;
  goto g6418;

g6408:
  if (_trace) printf("g6408:\n");
  /* not an instance, flavor description comes from magic vector */
  arg2 = *(u64 *)&(processor->trapvecbase);
  /* TagType. */
  t5 = arg3 & 63;
  arg2 = arg2 + 2560;
  arg2 = t5 + arg2;
  /* Memory Read Internal */

g6481:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6483;

g6482:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6485;
  goto g6407;

g6405:
  if (_trace) printf("g6405:\n");
  arg5 = arg2;
  arg2 = 34;
  goto illegaloperand;

g6406:
  if (_trace) printf("g6406:\n");
  arg5 = arg2;
  arg2 = 35;
  goto illegaloperand;

g6485:
  if (_trace) printf("g6485:\n");
  if ((t7 & 1) == 0)
    goto g6484;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6481;

g6484:
  if (_trace) printf("g6484:\n");

g6483:
  if (_trace) printf("g6483:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0011;
  goto memoryreaddatadecode;
return0011:
  r0 = *(u64 *)sp;
  goto g6407;

/* end LookupHandler */
/* start DoSetTag */

  /* Halfword operand from stack instruction - DoSetTag */
  /* arg2 has the preloaded 8 bit operand. */

dosettag:
  if (_trace) printf("dosettag:\n");
#ifdef TRACING
#endif

DoSetTagSP:
  if (_trace) printf("DoSetTagSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindosettag;
#endif

DoSetTagLP:
  if (_trace) printf("DoSetTagLP:\n");
#ifdef TRACING
  goto begindosettag;
#endif

DoSetTagFP:
  if (_trace) printf("DoSetTagFP:\n");

begindosettag:
  if (_trace) printf("begindosettag:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get tag/data of op2 */
  t1 = *(s32 *)(arg1 + 4);
  arg2 = *(s32 *)arg1;
  t3 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t3 = t3 & 63;
  if (t3 != 0)
    goto settagexc;
#ifdef TRACING
  goto DoSetTagIM;
#endif

DoSetTagIM:
  if (_trace) printf("DoSetTagIM:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Set TAG of op1 */
  *(u32 *)(iSP + 4) = arg2;
  goto cachevalid;

settagexc:
  if (_trace) printf("settagexc:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoSetTag */
  /* End of Halfword operand from stack instruction - DoSetTag */
/* start DoCar */

  /* Halfword operand from stack instruction - DoCar */
  /* arg2 has the preloaded 8 bit operand. */

docar:
  if (_trace) printf("docar:\n");
#ifdef TRACING
#endif

DoCarSP:
  if (_trace) printf("DoCarSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindocar;
#endif

DoCarLP:
  if (_trace) printf("DoCarLP:\n");
#ifdef TRACING
  goto begindocar;
#endif

DoCarFP:
  if (_trace) printf("DoCarFP:\n");

begindocar:
  if (_trace) printf("begindocar:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Get the operand from the stack. */
  arg5 = *(s32 *)(arg1 + 4);
  arg6 = *(s32 *)arg1;
  r0 = (u64)&&return0012;
  goto carinternal;
return0012:
  /* set CDR-NEXT */
  t5 = arg5 & 63;
  *(u32 *)(iSP + 8) = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;
#ifdef TRACING
#endif

DoCarIM:
  goto doistageerror;

/* end DoCar */
  /* End of Halfword operand from stack instruction - DoCar */
/* start CarInternal */


carinternal:
  if (_trace) printf("carinternal:\n");
  sp = sp + -8;
  arg2 = (u32)(arg6 >> ((zero&7)*8));
  /* Strip off any CDR code bits. */
  t5 = arg5 & 63;
  t6 = (t5 == Type_List) ? 1 : 0;

g6512:
  if (_trace) printf("g6512:\n");
  if (t6 == 0)
    goto g6495;
  /* Here if argument TypeList */

g6492:
  /* Memory Read Internal */

g6496:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6498;

g6497:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6500;

g6507:

g6494:
  if (_trace) printf("g6494:\n");

g6493:
  if (_trace) printf("g6493:\n");
  sp = sp + 8;
  goto *r0; /* ret */

g6495:
  if (_trace) printf("g6495:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;

g6513:
  if (_trace) printf("g6513:\n");
  if (t6 != 0)
    goto g6494;

g6508:
  if (_trace) printf("g6508:\n");
  t6 = (t5 == Type_Locative) ? 1 : 0;

g6514:
  if (_trace) printf("g6514:\n");
  if (t6 != 0)
    goto g6492;

g6509:
  if (_trace) printf("g6509:\n");
  /* Here for all other cases */
  /* arg6 = tag to dispatch on */
  arg6 = arg5;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto listexception;

g6500:
  if (_trace) printf("g6500:\n");
  if ((t7 & 1) == 0)
    goto g6499;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6496;

g6499:
  if (_trace) printf("g6499:\n");

g6498:
  if (_trace) printf("g6498:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0013;
  goto memoryreaddatadecode;
return0013:
  r0 = *(u64 *)sp;
  goto g6507;

/* end CarInternal */
/* start DoCdr */

  /* Halfword operand from stack instruction - DoCdr */
  /* arg2 has the preloaded 8 bit operand. */

docdr:
  if (_trace) printf("docdr:\n");
#ifdef TRACING
#endif

DoCdrSP:
  if (_trace) printf("DoCdrSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindocdr;
#endif

DoCdrLP:
  if (_trace) printf("DoCdrLP:\n");
#ifdef TRACING
  goto begindocdr;
#endif

DoCdrFP:
  if (_trace) printf("DoCdrFP:\n");

begindocdr:
  if (_trace) printf("begindocdr:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Get the operand from the stack. */
  arg5 = *(s32 *)(arg1 + 4);
  arg6 = *(s32 *)arg1;
  r0 = (u64)&&return0014;
  goto cdrinternal;
return0014:
  /* set CDR-NEXT */
  t5 = arg5 & 63;
  *(u32 *)(iSP + 8) = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;
#ifdef TRACING
#endif

DoCdrIM:
  goto doistageerror;

/* end DoCdr */
  /* End of Halfword operand from stack instruction - DoCdr */
/* start CdrInternal */


cdrinternal:
  if (_trace) printf("cdrinternal:\n");
  sp = sp + -8;
  arg2 = (u32)arg6;
  /* Strip off any CDR code bits. */
  t5 = arg5 & 63;
  t6 = (t5 == Type_List) ? 1 : 0;

g6550:
  if (_trace) printf("g6550:\n");
  if (t6 == 0)
    goto g6518;
  /* Here if argument TypeList */
  /* Memory Read Internal */

g6519:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->cdr_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6521;

g6520:
  t7 = zero + 192;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6523;

g6528:
  /* Extract CDR code. */
  t5 = arg5 & 192;
  if (t5 != 0)
    goto g6530;
  /* Here if argument 0 */
  /* Address of next position is CDR */
  arg6 = arg2 + 1;
  arg5 = Type_List;

g6529:
  if (_trace) printf("g6529:\n");

g6517:
  if (_trace) printf("g6517:\n");

g6516:
  if (_trace) printf("g6516:\n");
  sp = sp + 8;
  goto *r0; /* ret */

g6518:
  if (_trace) printf("g6518:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;

g6551:
  if (_trace) printf("g6551:\n");
  if (t6 != 0)
    goto g6517;

g6546:
  if (_trace) printf("g6546:\n");
  t6 = (t5 == Type_Locative) ? 1 : 0;

g6552:
  if (_trace) printf("g6552:\n");
  if (t6 != 0)
    goto g6515;

g6547:
  if (_trace) printf("g6547:\n");
  /* Here for all other cases */
  /* arg6 = tag to dispatch on */
  arg6 = arg5;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto listexception;

g6530:
  if (_trace) printf("g6530:\n");
  t6 = (t5 == 128) ? 1 : 0;

g6553:
  if (_trace) printf("g6553:\n");
  if (t6 == 0)
    goto g6531;
  /* Here if argument 128 */
  arg2 = arg2 + 1;

g6515:
  if (_trace) printf("g6515:\n");
  /* Memory Read Internal */

g6532:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6534;

g6533:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6536;
  goto g6516;

g6531:
  if (_trace) printf("g6531:\n");
  t6 = (t5 == 64) ? 1 : 0;

g6554:
  if (_trace) printf("g6554:\n");
  if (t6 == 0)
    goto g6543;
  /* Here if argument 64 */
  arg6 = *(s32 *)&processor->niladdress;
  arg5 = *((s32 *)(&processor->niladdress)+1);
  arg6 = (u32)arg6;
  goto g6516;

g6543:
  if (_trace) printf("g6543:\n");
  /* Here for all other cases */
  arg5 = arg2;
  arg2 = 15;
  goto illegaloperand;

g6536:
  if (_trace) printf("g6536:\n");
  if ((t7 & 1) == 0)
    goto g6535;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6532;

g6535:
  if (_trace) printf("g6535:\n");

g6534:
  if (_trace) printf("g6534:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0015;
  goto memoryreaddatadecode;
return0015:
  r0 = *(u64 *)sp;
  goto g6516;

g6523:
  if (_trace) printf("g6523:\n");
  if ((t7 & 1) == 0)
    goto g6522;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6519;

g6522:
  if (_trace) printf("g6522:\n");

g6521:
  if (_trace) printf("g6521:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0016;
  goto memoryreadcdrdecode;
return0016:
  r0 = *(u64 *)sp;
  goto g6528;

/* end CdrInternal */
/* start DoReadInternalRegister */

  /* Halfword 10 bit immediate instruction - DoReadInternalRegister */

doreadinternalregister:
  if (_trace) printf("doreadinternalregister:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoReadInternalRegisterIM:
  if (_trace) printf("DoReadInternalRegisterIM:\n");

DoReadInternalRegisterSP:
  if (_trace) printf("DoReadInternalRegisterSP:\n");

DoReadInternalRegisterLP:
  if (_trace) printf("DoReadInternalRegisterLP:\n");

DoReadInternalRegisterFP:
  if (_trace) printf("DoReadInternalRegisterFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  t2 = *(u64 *)&(processor->internalregisterread2);
  t3 = (s32)arg1 - (s32)512;
  t1 = *(u64 *)&(processor->internalregisterread1);
  /* We're in the 1000's */
  if ((s64)t3 >= 0)
    goto g6555;
  /* Keep only six bits */
  t3 = arg1 & 63;
  /* In range for the low registers? */
  t2 = ((s64)t3 <= (s64)42) ? 1 : 0;
  t3 = (t3 * 8) + t1;
  if (t2 == 0)
    goto ReadRegisterError;
  t3 = *(u64 *)t3;
  /* Jump to the handler */
    goto *t3; /* jmp */

g6555:
  if (_trace) printf("g6555:\n");
  /* In range for the high registers? */
  t1 = ((s64)t3 <= (s64)33) ? 1 : 0;
  t3 = (t3 * 8) + t2;
  if (t1 == 0)
    goto ReadRegisterError;
  t3 = *(u64 *)t3;
  /* Jump to the handler */
    goto *t3; /* jmp */

/* end DoReadInternalRegister */
  /* End of Halfword operand from stack instruction - DoReadInternalRegister */
/* start DoWriteInternalRegister */

  /* Halfword 10 bit immediate instruction - DoWriteInternalRegister */

dowriteinternalregister:
  if (_trace) printf("dowriteinternalregister:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoWriteInternalRegisterIM:
  if (_trace) printf("DoWriteInternalRegisterIM:\n");

DoWriteInternalRegisterSP:
  if (_trace) printf("DoWriteInternalRegisterSP:\n");

DoWriteInternalRegisterLP:
  if (_trace) printf("DoWriteInternalRegisterLP:\n");

DoWriteInternalRegisterFP:
  if (_trace) printf("DoWriteInternalRegisterFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u32)(arg6 >> ((4&7)*8));
  /* Arg2=tag arg3=data */
  arg3 = (u32)arg6;
  /* Pop Stack. */
  iSP = iSP - 8;
  t2 = *(u64 *)&(processor->internalregisterwrite2);
  t3 = (s32)arg1 - (s32)512;
  t1 = *(u64 *)&(processor->internalregisterwrite1);
  /* We're in the 1000's */
  if ((s64)t3 >= 0)
    goto g6556;
  /* Keep only six bits */
  t3 = arg1 & 63;
  /* In range for the low registers? */
  t2 = ((s64)t3 <= (s64)42) ? 1 : 0;
  t3 = (t3 * 8) + t1;
  if (t2 == 0)
    goto WriteRegisterError;
  t3 = *(u64 *)t3;
  /* Jump to the handler */
    goto *t3; /* jmp */

g6556:
  if (_trace) printf("g6556:\n");
  /* In range for the high registers? */
  t1 = ((s64)t3 <= (s64)33) ? 1 : 0;
  t3 = (t3 * 8) + t2;
  if (t1 == 0)
    goto WriteRegisterError;
  t3 = *(u64 *)t3;
  /* Jump to the handler */
    goto *t3; /* jmp */

/* end DoWriteInternalRegister */
  /* End of Halfword operand from stack instruction - DoWriteInternalRegister */
/* start WriteRegisterBARx */


WriteRegisterBARx:
  if (_trace) printf("WriteRegisterBARx:\n");
  /* BAR number into T2 */
  t2 = arg1 >> 7;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Make a quadword from tag and data */
  t3 = arg2 << 32;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t1 = (u64)&processor->bar0;
  /* Now T1 points to the BAR */
  t1 = (t2 * 8) + t1;
  /* Construct the combined word */
  t3 = t3 | arg3;
  *(u64 *)t1 = t3;
  goto cachevalid;

/* end WriteRegisterBARx */
/* start DoBlock3Read */

  /* Halfword 10 bit immediate instruction - DoBlock3Read */

doblock3read:
  if (_trace) printf("doblock3read:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock3ReadIM:
  if (_trace) printf("DoBlock3ReadIM:\n");

DoBlock3ReadSP:
  if (_trace) printf("DoBlock3ReadSP:\n");

DoBlock3ReadLP:
  if (_trace) printf("DoBlock3ReadLP:\n");

DoBlock3ReadFP:
  if (_trace) printf("DoBlock3ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar3;
  goto blockread;

/* end DoBlock3Read */
  /* End of Halfword operand from stack instruction - DoBlock3Read */
/* start DoBlock2Read */

  /* Halfword 10 bit immediate instruction - DoBlock2Read */

doblock2read:
  if (_trace) printf("doblock2read:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock2ReadIM:
  if (_trace) printf("DoBlock2ReadIM:\n");

DoBlock2ReadSP:
  if (_trace) printf("DoBlock2ReadSP:\n");

DoBlock2ReadLP:
  if (_trace) printf("DoBlock2ReadLP:\n");

DoBlock2ReadFP:
  if (_trace) printf("DoBlock2ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar2;
  goto blockread;

/* end DoBlock2Read */
  /* End of Halfword operand from stack instruction - DoBlock2Read */
/* start DoBlock1Read */

  /* Halfword 10 bit immediate instruction - DoBlock1Read */

doblock1read:
  if (_trace) printf("doblock1read:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock1ReadIM:
  if (_trace) printf("DoBlock1ReadIM:\n");

DoBlock1ReadSP:
  if (_trace) printf("DoBlock1ReadSP:\n");

DoBlock1ReadLP:
  if (_trace) printf("DoBlock1ReadLP:\n");

DoBlock1ReadFP:
  if (_trace) printf("DoBlock1ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar1;

blockread:
  if (_trace) printf("blockread:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Get the vma */
  arg2 = *(s32 *)arg4;
  /* cycle type */
  arg3 = arg1 >> 6;
  /* =no-incrementp */
  t2 = arg1 & 4;
  /* =cdr-code-nextp */
  t3 = arg1 & 16;
  /* =fixnum onlyp */
  t4 = arg1 & 32;
  arg2 = (u32)arg2;
  /* Do the read cycle */
  /* Memory Read Internal */

g6560:
  t7 = arg2 + ivory;
  /* Cycle-number -> table offset */
  t8 = (arg3 * 4);
  arg5 = LDQ_U(t7);
  t8 = (t8 * 4) + ivory;
  arg6 = (t7 * 4);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6562;

g6561:
  t8 = t8 >> (arg5 & 63);
  if (t8 & 1)
    goto g6564;

g6571:
  /* J. if we have to test for fixnump. */
  if (t4 != 0)
    goto g6557;

g6558:
  /* Compute Incremented address */
  t4 = arg2 + 1;

g6572:
  if (_trace) printf("g6572:\n");
  /* Conditionally update address */
  if (t2 == 0)
    arg2 = t4;
  /* Store updated vma in BAR */
  *(u32 *)arg4 = arg2;
  /* Compute CDR-NEXT */
  t2 = arg5 & 63;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Conditionally Set CDR-NEXT */
  if (t3)
    arg5 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)(iSP + 8) = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = arg5;
  iSP = iSP + 8;
  goto cachevalid;

g6559:
  if (_trace) printf("g6559:\n");
  arg5 = arg2;
  arg2 = 23;
  goto illegaloperand;

g6564:
  if (_trace) printf("g6564:\n");

g6562:
  if (_trace) printf("g6562:\n");
  r0 = (u64)&&return0017;
  goto memoryreadgeneraldecode;
return0017:
  goto g6571;

g6557:
  if (_trace) printf("g6557:\n");
  t5 = arg5 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g6559;
  goto g6558;

/* end DoBlock1Read */
  /* End of Halfword operand from stack instruction - DoBlock1Read */
/* start DoBlock2Write */

  /* Halfword operand from stack instruction - DoBlock2Write */

doblock2write:
  if (_trace) printf("doblock2write:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoBlock2WriteIM:
  if (_trace) printf("DoBlock2WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g6589:
  if (_trace) printf("g6589:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoblock2write;
#ifdef TRACING
#endif

DoBlock2WriteSP:
  if (_trace) printf("DoBlock2WriteSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoblock2write;
#endif

DoBlock2WriteLP:
  if (_trace) printf("DoBlock2WriteLP:\n");
#ifdef TRACING
  goto headdoblock2write;
#endif

DoBlock2WriteFP:
  if (_trace) printf("DoBlock2WriteFP:\n");

headdoblock2write:
  if (_trace) printf("headdoblock2write:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoblock2write:
  if (_trace) printf("begindoblock2write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar2;
  arg2 = (u64)&processor->bar2;
  goto blockwrite;

/* end DoBlock2Write */
  /* End of Halfword operand from stack instruction - DoBlock2Write */
/* start DoBlock1Write */

  /* Halfword operand from stack instruction - DoBlock1Write */

doblock1write:
  if (_trace) printf("doblock1write:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoBlock1WriteIM:
  if (_trace) printf("DoBlock1WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g6593:
  if (_trace) printf("g6593:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoblock1write;
#ifdef TRACING
#endif

DoBlock1WriteSP:
  if (_trace) printf("DoBlock1WriteSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoblock1write;
#endif

DoBlock1WriteLP:
  if (_trace) printf("DoBlock1WriteLP:\n");
#ifdef TRACING
  goto headdoblock1write;
#endif

DoBlock1WriteFP:
  if (_trace) printf("DoBlock1WriteFP:\n");

headdoblock1write:
  if (_trace) printf("headdoblock1write:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoblock1write:
  if (_trace) printf("begindoblock1write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar1;
  arg2 = (u64)&processor->bar1;

blockwrite:
  if (_trace) printf("blockwrite:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Unsigned vma */
  arg3 = (u32)arg3;
  /* Get tag */
  t2 = arg1 >> 32;
  /* Get data */
  t3 = (u32)arg1;
  t8 = arg3 + ivory;
  t6 = (t8 * 4);
  t5 = LDQ_U(t8);
  /* Stack cache offset */
  t4 = arg3 - t11;
  /* In range? */
  t7 = ((u64)t4 < (u64)t12) ? 1 : 0;
  t4 = (t2 & 0xff) << ((t8&7)*8);
  t5 = t5 & ~(0xffL << (t8&7)*8);

g6592:
  if (_trace) printf("g6592:\n");
  t5 = t5 | t4;
  STQ_U(t8, t5);
  *(u32 *)t6 = t3;
  /* J. if in cache */
  if (t7 != 0)
    goto g6591;

g6590:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Increment the address */
  arg3 = arg3 + 1;
  /* Store updated vma in BAR */
  *(u32 *)arg2 = arg3;
  goto cachevalid;

g6591:
  if (_trace) printf("g6591:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t4 = arg3 - t11;
  /* reconstruct SCA */
  t8 = (t4 * 8) + t8;
  /* Store in stack */
  *(u32 *)t8 = t3;
  /* write the stack cache */
  *(u32 *)(t8 + 4) = t2;
  goto g6590;

/* end DoBlock1Write */
  /* End of Halfword operand from stack instruction - DoBlock1Write */
/* start DoBranchTrueNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueNoPop */

dobranchtruenopop:
  if (_trace) printf("dobranchtruenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueNoPopIM:
  if (_trace) printf("DoBranchTrueNoPopIM:\n");

DoBranchTrueNoPopSP:
  if (_trace) printf("DoBranchTrueNoPopSP:\n");

DoBranchTrueNoPopLP:
  if (_trace) printf("DoBranchTrueNoPopLP:\n");

DoBranchTrueNoPopFP:
  if (_trace) printf("DoBranchTrueNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 == 0)
    goto NEXTINSTRUCTION;
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchTrueNoPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueNoPop */
/* start DoBranchFalseNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseNoPop */

dobranchfalsenopop:
  if (_trace) printf("dobranchfalsenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseNoPopIM:
  if (_trace) printf("DoBranchFalseNoPopIM:\n");

DoBranchFalseNoPopSP:
  if (_trace) printf("DoBranchFalseNoPopSP:\n");

DoBranchFalseNoPopLP:
  if (_trace) printf("DoBranchFalseNoPopLP:\n");

DoBranchFalseNoPopFP:
  if (_trace) printf("DoBranchFalseNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 != 0)
    goto NEXTINSTRUCTION;
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchFalseNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseNoPop */
/* start callgeneric */

  /* Fullword instruction - callgeneric */
#ifdef TRACING
#endif

callgeneric:
  if (_trace) printf("callgeneric:\n");

callgenericprefetch:
  if (_trace) printf("callgenericprefetch:\n");
  t3 = *(u64 *)&(processor->trapvecbase);
  /* Get operand */
  arg4 = arg3;
  arg3 = Type_GenericFunction;
  arg5 = Type_EvenPC;
  arg6 = t3 + 2636;
  goto startcallcompiledmerge;

/* end callgeneric */
  /* End of Fullword instruction - callgeneric */
/* start callcompiledeven */

  /* Fullword instruction - callcompiledeven */
#ifdef TRACING
#endif

callcompiledeven:
  if (_trace) printf("callcompiledeven:\n");

callcompiledevenprefetch:
  if (_trace) printf("callcompiledevenprefetch:\n");
  /* Get operand */
  arg6 = arg3;
  arg5 = Type_EvenPC;
  /* No extra arg */
  arg3 = zero;
  goto startcallcompiledmerge;

/* end callcompiledeven */
  /* End of Fullword instruction - callcompiledeven */
/* start DoStartCall */

  /* Halfword operand from stack instruction - DoStartCall */
  /* arg2 has the preloaded 8 bit operand. */

dostartcall:
  if (_trace) printf("dostartcall:\n");
#ifdef TRACING
#endif

DoStartCallSP:
  if (_trace) printf("DoStartCallSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindostartcall;
#endif

DoStartCallLP:
  if (_trace) printf("DoStartCallLP:\n");
#ifdef TRACING
  goto begindostartcall;
#endif

DoStartCallFP:
  if (_trace) printf("DoStartCallFP:\n");

begindostartcall:
  if (_trace) printf("begindostartcall:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg5 = *(s32 *)(arg1 + 4);
  arg6 = *(s32 *)arg1;

startcallagain:
  if (_trace) printf("startcallagain:\n");

g6596:
  if (_trace) printf("g6596:\n");
  t1 = *(u64 *)&(processor->trapvecbase);
  /* Strip off any CDR code bits. */
  t2 = arg5 & 63;
  t3 = (t2 == Type_CompiledFunction) ? 1 : 0;

g6645:
  if (_trace) printf("g6645:\n");
  if (t3 == 0)
    goto g6602;
  /* Here if argument TypeCompiledFunction */

g6597:
  if (_trace) printf("g6597:\n");
  /* No extra argument */
  arg3 = zero;

g6598:
  if (_trace) printf("g6598:\n");
  arg5 = Type_EvenPC;

startcallcompiledmerge:
  if (_trace) printf("startcallcompiledmerge:\n");
  t7 = *((s32 *)(&processor->continuation)+1);
  /* prepare to push continuation/control register */
  iSP = iSP + 16;
  t3 = *(s32 *)&processor->control;
  t6 = Type_Fixnum+0xC0;
  t8 = *(s32 *)&processor->continuation;
  t5 = (64) << 16;
  /* Set CDR code 3 */
  t7 = t7 | 192;
  /* push continuation */
  *(u32 *)(iSP + -8) = t8;
  /* write the stack cache */
  *(u32 *)(iSP + -4) = t7;
  /* Set call started bit in CR */
  t8 = t3 | t5;
  t5 = zero + 256;
  /* Push control register */
  *(u32 *)iSP = t3;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  /* Clear the extra arg bit */
  t8 = t8 & ~t5;
  /* Save control with new state */
  *(u32 *)&processor->control = t8;
  /* End of push-frame */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)&processor->continuation = arg6;
  *((u32 *)(&processor->continuation)+1) = arg5;
  *(u64 *)&processor->continuationcp = zero;
  if (arg3 != 0)
    goto g6599;
  goto cachevalid;

g6599:
  if (_trace) printf("g6599:\n");
  t1 = *(s32 *)&processor->control;
  t2 = zero + 256;
  /* set CDR-NEXT */
  t3 = arg3 & 63;
  /* Push the extra arg. */
  *(u32 *)(iSP + 8) = arg4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  /* Set the extra arg bit */
  t1 = t1 | t2;
  /* Save control with new state */
  *(u32 *)&processor->control = t1;
  goto cachevalid;

g6602:
  if (_trace) printf("g6602:\n");
  t3 = (t2 == Type_GenericFunction) ? 1 : 0;

g6646:
  if (_trace) printf("g6646:\n");
  if (t3 == 0)
    goto g6603;
  /* Here if argument TypeGenericFunction */
  arg3 = arg5;
  arg4 = (u32)arg6;
  arg6 = t1 + 2636;
  goto g6598;

g6603:
  if (_trace) printf("g6603:\n");
  t3 = (t2 == Type_Instance) ? 1 : 0;

g6647:
  if (_trace) printf("g6647:\n");
  if (t3 == 0)
    goto g6604;
  /* Here if argument TypeInstance */
  arg3 = arg5;
  arg4 = (u32)arg6;
  arg6 = t1 + 2638;
  goto g6598;

g6604:
  if (_trace) printf("g6604:\n");
  t3 = (t2 == Type_Symbol) ? 1 : 0;

g6648:
  if (_trace) printf("g6648:\n");
  if (t3 == 0)
    goto g6605;
  /* Here if argument TypeSymbol */
  arg6 = (u32)arg6;
  /* No extra argument */
  arg3 = zero;
  /* Get to the function cell */
  arg2 = arg6 + 2;
  goto startcallindirect;

g6605:
  if (_trace) printf("g6605:\n");
  t3 = (t2 == Type_LexicalClosure) ? 1 : 0;

g6649:
  if (_trace) printf("g6649:\n");
  if (t3 == 0)
    goto g6606;
  /* Here if argument TypeLexicalClosure */
  arg2 = (u32)arg6;
  /* Memory Read Internal */

g6607:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6609;

g6608:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6611;

g6618:
  arg3 = arg5;
  arg4 = arg6;
  arg2 = arg2 + 1;

startcallindirect:
  if (_trace) printf("startcallindirect:\n");
  /* Memory Read Internal */

g6619:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6621;

g6620:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6623;

g6630:
  t5 = arg5 - Type_CompiledFunction;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g6596;
  goto g6598;

g6606:
  if (_trace) printf("g6606:\n");
  /* Here for all other cases */

g6594:
  if (_trace) printf("g6594:\n");
  arg3 = arg5;
  arg4 = arg6;
  t3 = t1 + 2304;
  /* TagType. */
  arg5 = arg5 & 63;
  arg2 = arg5 + t3;
  /* Memory Read Internal */

g6632:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6634;

g6633:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6636;

g6643:
  t3 = arg5 - Type_EvenPC;
  /* Strip CDR code, low bits */
  t3 = t3 & 63;
  if (t3 != 0)
    goto g6595;
  goto g6598;

g6601:
  if (_trace) printf("g6601:\n");

g6595:
  if (_trace) printf("g6595:\n");
  arg5 = t1;
  arg2 = 51;
  goto illegaloperand;

g6636:
  if (_trace) printf("g6636:\n");
  if ((t7 & 1) == 0)
    goto g6635;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6632;

g6635:
  if (_trace) printf("g6635:\n");

g6634:
  if (_trace) printf("g6634:\n");
  r0 = (u64)&&return0018;
  goto memoryreaddatadecode;
return0018:
  goto g6643;

g6623:
  if (_trace) printf("g6623:\n");
  if ((t7 & 1) == 0)
    goto g6622;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6619;

g6622:
  if (_trace) printf("g6622:\n");

g6621:
  if (_trace) printf("g6621:\n");
  r0 = (u64)&&return0019;
  goto memoryreaddatadecode;
return0019:
  goto g6630;

g6611:
  if (_trace) printf("g6611:\n");
  if ((t7 & 1) == 0)
    goto g6610;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6607;

g6610:
  if (_trace) printf("g6610:\n");

g6609:
  if (_trace) printf("g6609:\n");
  r0 = (u64)&&return0020;
  goto memoryreaddatadecode;
return0020:
  goto g6618;
#ifdef TRACING
#endif

DoStartCallIM:
  goto doistageerror;

/* end DoStartCall */
  /* End of Halfword operand from stack instruction - DoStartCall */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuncom1.as */
